{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"interposition","text":"<p>Protocol-agnostic interaction interposition with lifecycle hooks for record, replay, and control.</p>"},{"location":"#overview","title":"Overview","text":"<p>Interposition is a Python library for replaying recorded interactions. Unlike VCRpy or other HTTP-specific tools, Interposition does not automatically hook into network libraries.</p> <p>Instead, it provides a pure logic engine for storage, matching, and replay. You write the adapter for your specific target (HTTP client, database driver, IoT message handler), and Interposition handles the rest.</p> <p>Key Features:</p> <ul> <li>Protocol-agnostic: Works with any protocol (HTTP, gRPC, SQL, Pub/Sub, etc.)</li> <li>Type-safe: Full mypy strict mode support with Pydantic v2</li> <li>Immutable: All data structures are frozen Pydantic models</li> <li>Serializable: Built-in JSON/YAML serialization for cassette persistence</li> <li>Memory-efficient: O(1) lookup with fingerprint indexing</li> <li>Streaming: Generator-based response delivery</li> <li>Multi-mode: Supports replay, record, and auto modes</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<p>Interposition sits behind your application's data access layer. You provide the \"Adapter\" that captures live traffic or requests replay from the Broker.</p> <pre><code>+-------------+      +------------------+      +---------------+\n| Application | &lt;--&gt; | Your Adapter     | &lt;--&gt; | Interposition |\n+-------------+      +------------------+      +---------------+\n                            |                          |\n                       (Traps calls)              (Manages)\n                                                       |\n                                                  [Cassette]\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install interposition\n</code></pre>"},{"location":"#practical-integration-pytest-recipe","title":"Practical Integration (Pytest Recipe)","text":"<p>The most common use case is using Interposition as a test fixture. Here is a production-ready recipe for <code>pytest</code>:</p> <pre><code>import pytest\nfrom interposition import Broker, Cassette, InteractionRequest\n\n@pytest.fixture\ndef cassette_broker():\n    # Load cassette from a JSON file (or create one programmatically)\n    with open(\"tests/fixtures/my_cassette.json\", \"rb\") as f:\n        cassette = Cassette.model_validate_json(f.read())\n    return Broker(cassette)\n\ndef test_user_service(cassette_broker, monkeypatch):\n    # 1. Create your adapter (mocking your actual client)\n    def mock_fetch(url):\n        request = InteractionRequest(\n            protocol=\"http\",\n            action=\"GET\",\n            target=url,\n            headers=(),\n            body=b\"\",\n        )\n        # Delegate to Interposition\n        chunks = list(cassette_broker.replay(request))\n        return chunks[0].data\n\n    # 2. Inject the adapter\n    monkeypatch.setattr(\"my_app.client.fetch\", mock_fetch)\n\n    # 3. Run your test\n    from my_app import get_user_name\n    assert get_user_name(42) == \"Alice\"\n</code></pre>"},{"location":"#protocol-agnostic-examples","title":"Protocol-Agnostic Examples","text":"<p>Interposition shines where HTTP-only tools fail.</p>"},{"location":"#sql-database-query","title":"SQL Database Query","text":"<pre><code>request = InteractionRequest(\n    protocol=\"postgres\",\n    action=\"SELECT\",\n    target=\"users_table\",\n    headers=(),\n    body=b\"SELECT id, name FROM users WHERE id = 42\",\n)\n# Replay returns: b'[(42, \"Alice\")]'\n</code></pre>"},{"location":"#mqtt-pubsub-message","title":"MQTT / PubSub Message","text":"<pre><code>request = InteractionRequest(\n    protocol=\"mqtt\",\n    action=\"subscribe\",\n    target=\"sensors/temp/room1\",\n    headers=((\"qos\", \"1\"),),\n    body=b\"\",\n)\n# Replay returns stream of messages: b'24.5', b'24.6', ...\n</code></pre>"},{"location":"#usage-guide","title":"Usage Guide","text":""},{"location":"#manual-construction-quick-start","title":"Manual Construction (Quick Start)","text":"<p>If you need to build interactions programmatically (e.g., for seeding tests):</p> <pre><code>from interposition import (\n    Broker,\n    Cassette,\n    Interaction,\n    InteractionRequest,\n    ResponseChunk,\n)\n\n# 1. Define the Request\nrequest = InteractionRequest(\n    protocol=\"api\",\n    action=\"query\",\n    target=\"users/42\",\n    headers=(),\n    body=b\"\",\n)\n\n# 2. Define the Response\nchunks = (\n    ResponseChunk(data=b'{\"id\": 42, \"name\": \"Alice\"}', sequence=0),\n)\n\n# 3. Create Interaction &amp; Cassette\ninteraction = Interaction(\n    request=request,\n    fingerprint=request.fingerprint(),\n    response_chunks=chunks,\n)\ncassette = Cassette(interactions=(interaction,))\n\n# 4. Replay\nbroker = Broker(cassette=cassette)\nresponse = list(broker.replay(request))\n</code></pre>"},{"location":"#persistence-serialization","title":"Persistence &amp; Serialization","text":"<p>Interposition models are Pydantic v2 models, making serialization trivial.</p> <pre><code># Save to JSON\nwith open(\"cassette.json\", \"w\") as f:\n    f.write(cassette.model_dump_json(indent=2))\n\n# Load from JSON\nwith open(\"cassette.json\") as f:\n    cassette = Cassette.model_validate_json(f.read())\n\n# Generate JSON Schema\nschema = Cassette.model_json_schema()\n</code></pre>"},{"location":"#streaming-responses","title":"Streaming Responses","text":"<p>For large files or streaming protocols, responses are yielded lazily:</p> <pre><code># The broker returns a generator\nfor chunk in broker.replay(request):\n    print(f\"Received chunk: {len(chunk.data)} bytes\")\n</code></pre>"},{"location":"#broker-modes","title":"Broker Modes","text":"<p>The <code>Broker</code> supports three modes via the <code>mode</code> parameter:</p> Mode Behavior <code>replay</code> Default. Returns recorded responses only. Raises <code>InteractionNotFoundError</code> on cache miss. <code>record</code> Always forwards to live responder and records. Ignores existing cassette entries. <code>auto</code> Returns recorded response if available; otherwise forwards to live and records. <p>The <code>BrokerMode</code> type alias is available for type hints:</p> <pre><code>from interposition import BrokerMode\n\nmode: BrokerMode = \"auto\"\n</code></pre>"},{"location":"#live-responder","title":"Live Responder","text":"<p>For <code>record</code> and <code>auto</code> modes, you must provide a <code>live_responder</code> callable that forwards requests to your actual backend:</p> <pre><code>from interposition import (\n    Broker,\n    Cassette,\n    InteractionRequest,\n    ResponseChunk,\n)\nfrom collections.abc import Iterable\n\ndef my_live_responder(request: InteractionRequest) -&gt; Iterable[ResponseChunk]:\n    \"\"\"Forward request to actual backend and yield response chunks.\"\"\"\n    # Your actual implementation here\n    response = your_http_client.request(\n        method=request.action,\n        url=request.target,\n        headers=dict(request.headers),\n        data=request.body,\n    )\n    yield ResponseChunk(data=response.content, sequence=0)\n</code></pre> <p>The <code>LiveResponder</code> type alias is available:</p> <pre><code>from interposition.services import LiveResponder\n</code></pre>"},{"location":"#record-mode","title":"Record Mode","text":"<p>Use <code>record</code> mode to capture new interactions:</p> <pre><code># Start with empty cassette\ncassette = Cassette(interactions=())\n\nbroker = Broker(\n    cassette=cassette,\n    mode=\"record\",\n    live_responder=my_live_responder,\n)\n\n# All requests are forwarded and recorded\nresponse = list(broker.replay(request))\n\n# Save the updated cassette\nwith open(\"cassette.json\", \"w\") as f:\n    f.write(broker.cassette.model_dump_json(indent=2))\n</code></pre>"},{"location":"#auto-mode","title":"Auto Mode","text":"<p>Use <code>auto</code> mode for hybrid workflows (replay if available, record if not):</p> <pre><code># Load existing cassette (may be empty or partial)\nwith open(\"cassette.json\") as f:\n    cassette = Cassette.model_validate_json(f.read())\n\nbroker = Broker(\n    cassette=cassette,\n    mode=\"auto\",\n    live_responder=my_live_responder,\n)\n\n# Returns recorded response if exists, otherwise forwards and records\nresponse = list(broker.replay(request))\n</code></pre>"},{"location":"#cassette-store","title":"Cassette Store","text":"<p>For automatic cassette persistence during recording, use a <code>CassetteStore</code>. The <code>CassetteStore</code> protocol defines a simple interface for loading and saving cassettes:</p> <pre><code>from interposition import CassetteStore\n\nclass MyCassetteStore:\n    \"\"\"Custom store implementation.\"\"\"\n\n    def load(self) -&gt; Cassette:\n        \"\"\"Load cassette from storage.\"\"\"\n        ...\n\n    def save(self, cassette: Cassette) -&gt; None:\n        \"\"\"Save cassette to storage.\"\"\"\n        ...\n</code></pre> <p>When a <code>cassette_store</code> is provided to the <code>Broker</code>, it automatically saves the cassette after each recorded interaction.</p>"},{"location":"#jsonfilecassettestore","title":"JsonFileCassetteStore","text":"<p>A built-in file-based cassette store using JSON format:</p> <pre><code>from pathlib import Path\nfrom interposition import Broker, Cassette, JsonFileCassetteStore\n\n# Create store pointing to a JSON file\nstore = JsonFileCassetteStore(Path(\"cassettes/my_test.json\"))\n\n# Load existing cassette (raises FileNotFoundError if not exists)\ncassette = store.load()\n\n# Or start with empty cassette\ncassette = Cassette(interactions=())\n\n# Create broker with automatic persistence\nbroker = Broker(\n    cassette=cassette,\n    mode=\"record\",\n    live_responder=my_live_responder,\n    cassette_store=store,  # Auto-saves after each recording\n)\n\n# After replay, cassette is automatically saved to file\nresponse = list(broker.replay(request))\n</code></pre> <p>The <code>JsonFileCassetteStore</code> creates parent directories automatically when saving. If saving fails, the error is propagated and response streaming stops (fail-fast).</p>"},{"location":"#error-handling","title":"Error Handling","text":"<p>All interposition exceptions inherit from <code>InterpositionError</code>, allowing you to catch all domain errors with a single handler:</p> <pre><code>from interposition import InterpositionError\n\ntry:\n    broker.replay(request)\nexcept InterpositionError as e:\n    print(f\"Interposition error: {e}\")\n</code></pre> <p>InteractionNotFoundError: Raised when no matching interaction exists (in <code>replay</code> mode) or when <code>auto</code> mode has a cache miss without a configured <code>live_responder</code>:</p> <pre><code>from interposition import InteractionNotFoundError\n\ntry:\n    broker.replay(unknown_request)\nexcept InteractionNotFoundError as e:\n    print(f\"Not recorded: {e.request.target}\")\n</code></pre> <p>LiveResponderRequiredError: Raised when <code>record</code> mode is used without a <code>live_responder</code>:</p> <pre><code>from interposition import LiveResponderRequiredError\n\nbroker = Broker(cassette=cassette, mode=\"record\")  # No live_responder!\n\ntry:\n    broker.replay(request)\nexcept LiveResponderRequiredError as e:\n    print(f\"live_responder required for {e.mode} mode\")\n</code></pre> <p>InteractionValidationError: Raised when an <code>Interaction</code> fails validation (e.g., fingerprint mismatch or invalid response chunk sequence):</p> <pre><code>from interposition import Interaction, InteractionValidationError\n\ntry:\n    # This will fail: fingerprint doesn't match request\n    interaction = Interaction(\n        request=request,\n        fingerprint=wrong_fingerprint,  # Mismatch!\n        response_chunks=chunks,\n    )\nexcept InteractionValidationError as e:\n    print(f\"Validation failed: {e}\")\n</code></pre> <p>CassetteSaveError: Raised when <code>JsonFileCassetteStore.save()</code> fails due to I/O errors (permission denied, disk full, etc.):</p> <pre><code>from pathlib import Path\nfrom interposition import CassetteSaveError, JsonFileCassetteStore\n\nstore = JsonFileCassetteStore(Path(\"/readonly/cassette.json\"))\n\ntry:\n    store.save(cassette)\nexcept CassetteSaveError as e:\n    print(f\"Failed to save to {e.path}: {e.__cause__}\")\n</code></pre>"},{"location":"#version","title":"Version","text":"<p>Access the package version programmatically:</p> <pre><code>from interposition import __version__\n\nif __version__ &lt; \"0.2.0\":\n    print(\"Auto mode is not supported\")\nelse:\n    print(\"Auto mode is supported\")\n</code></pre>"},{"location":"#development","title":"Development","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>uv (recommended)</li> </ul>"},{"location":"#setup-testing","title":"Setup &amp; Testing","text":"<pre><code># Clone and install\ngit clone https://github.com/osoekawaitlab/interposition.git\ncd interposition\nuv pip install -e . --group=dev\n\n# Run tests\nnox -s tests\n</code></pre>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"adr/0000-adr-template/","title":"ADR 0000: This is ADR Template and Short Title of the Architectural Decision Goes Here","text":""},{"location":"adr/0000-adr-template/#status","title":"Status","text":"<p>[Proposed | Accepted | Deprecated | Superseded]</p>"},{"location":"adr/0000-adr-template/#date","title":"Date","text":"<p>YYYY-MM-DD</p>"},{"location":"adr/0000-adr-template/#context","title":"Context","text":"<p>Describe the context and problem statement. What is the architectural challenge that needs to be addressed? Include any relevant constraints or requirements that influenced the decision.</p>"},{"location":"adr/0000-adr-template/#decision","title":"Decision","text":"<p>State the architectural decision clearly and concisely. What specific approach, technology, pattern, or solution was chosen?</p>"},{"location":"adr/0000-adr-template/#rationale","title":"Rationale","text":"<p>Explain the reasoning that led to this decision. Why was this particular option selected among the alternatives? Include relevant factors such as:</p> <ul> <li>Technical considerations</li> <li>Business requirements</li> <li>Team capabilities</li> <li>Time constraints</li> <li>Cost implications</li> </ul>"},{"location":"adr/0000-adr-template/#implications","title":"Implications","text":""},{"location":"adr/0000-adr-template/#positive-implications","title":"Positive Implications","text":"<p>List the benefits and positive outcomes expected from this decision.</p>"},{"location":"adr/0000-adr-template/#concerns","title":"Concerns","text":"<p>List potential challenges, risks, or negative consequences along with possible mitigation strategies.</p>"},{"location":"adr/0000-adr-template/#alternatives","title":"Alternatives","text":"<p>Describe other options that were considered and why they were not selected. For each alternative, briefly explain:</p> <ul> <li>Key characteristics</li> <li>Pros and cons relative to the chosen solution</li> <li>Reasons for rejection</li> </ul>"},{"location":"adr/0000-adr-template/#future-direction","title":"Future Direction","text":"<p>Outline any follow-up actions, future considerations, or potential changes that might be necessary as a result of this decision. Include potential triggers for revisiting this decision.</p>"},{"location":"adr/0000-adr-template/#references","title":"References","text":"<p>List any relevant documents, articles, books, or other resources that supported this decision:</p> <ul> <li>Links to relevant documentation</li> <li>Research materials</li> <li>Benchmarks or performance data</li> <li>Team discussions or meeting notes</li> </ul>"},{"location":"adr/0001-pydantic-for-data-models/","title":"ADR 0001: Use Pydantic v2 for Data Models","text":""},{"location":"adr/0001-pydantic-for-data-models/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0001-pydantic-for-data-models/#date","title":"Date","text":"<p>2026-01-05</p>"},{"location":"adr/0001-pydantic-for-data-models/#context","title":"Context","text":"<p>Interposition's data models (ResponseChunk, InteractionRequest, RequestFingerprint, Interaction, Cassette) are immutable structures representing recorded interactions. The library needs:</p> <ol> <li>Serialization: Save/load cassettes to/from JSON files for persistence</li> <li>Runtime Validation: Validate data when loading cassettes from external sources</li> <li>Immutability: Prevent accidental modification of recorded data</li> </ol>"},{"location":"adr/0001-pydantic-for-data-models/#decision","title":"Decision","text":"<p>Use Pydantic v2 <code>BaseModel</code> with <code>ConfigDict(frozen=True)</code> for all data models.</p> <p>Domain services (e.g., Broker) use regular Python classes since they don't require serialization.</p>"},{"location":"adr/0001-pydantic-for-data-models/#rationale","title":"Rationale","text":"<ul> <li>Built-in Serialization: <code>model_dump_json()</code> and <code>model_validate_json()</code> eliminate need for custom serialization code</li> <li>Automatic Validation: Validates data at construction and deserialization, catching malformed cassette files</li> <li>Immutability: <code>ConfigDict(frozen=True)</code> provides same guarantees as frozen dataclasses</li> <li>Type Safety: Excellent mypy strict mode support via pydantic.mypy plugin</li> <li>Performance: Rust core makes validation overhead negligible</li> <li>Clean Validation API: <code>@model_validator</code> for cross-field validation (e.g., fingerprint matching)</li> </ul>"},{"location":"adr/0001-pydantic-for-data-models/#implications","title":"Implications","text":""},{"location":"adr/0001-pydantic-for-data-models/#positive","title":"Positive","text":"<ul> <li>Cassette persistence without custom code</li> <li>Automatic validation catches corrupted files</li> <li>JSON schema generation for documentation</li> </ul>"},{"location":"adr/0001-pydantic-for-data-models/#concerns","title":"Concerns","text":"<ul> <li>External dependency adds ~6MB to installation size (mitigation: Pydantic is widely adopted and well-maintained, risk is low)</li> <li>Developers need to learn Pydantic patterns (mitigation: Pydantic is industry standard with excellent documentation)</li> </ul>"},{"location":"adr/0001-pydantic-for-data-models/#alternatives","title":"Alternatives","text":""},{"location":"adr/0001-pydantic-for-data-models/#stdlib-frozen-dataclasses","title":"Stdlib Frozen Dataclasses","text":"<p>Using <code>@dataclass(frozen=True, slots=True)</code> from Python's standard library.</p> <ul> <li>Pros: No external dependencies, familiar to Python developers, memory efficient</li> <li>Cons: No built-in serialization, no validation hooks, would require ~200+ lines of custom serialization code</li> <li>Reason for rejection: Serialization is a core requirement; implementing it manually adds significant complexity</li> </ul>"},{"location":"adr/0001-pydantic-for-data-models/#attrs-cattrs","title":"attrs + cattrs","text":"<p>Using attrs for data classes and cattrs for serialization.</p> <ul> <li>Pros: Mature library, supports validation, serialization via cattrs</li> <li>Cons: Less widely adopted than Pydantic, more complex configuration, no built-in schema generation</li> <li>Reason for rejection: Pydantic has better ecosystem integration and built-in schema generation</li> </ul>"},{"location":"adr/0001-pydantic-for-data-models/#named-tuples","title":"Named Tuples","text":"<p>Using <code>typing.NamedTuple</code> for immutable data structures.</p> <ul> <li>Pros: Built-in, immutable by default, lightweight</li> <li>Cons: Poor ergonomics for models with many fields, no validation hooks, limited extensibility</li> <li>Reason for rejection: Lack of validation support makes it unsuitable for external data validation</li> </ul>"},{"location":"adr/0001-pydantic-for-data-models/#custom-classes","title":"Custom Classes","text":"<p>Implementing custom classes with manual <code>__init__</code>, <code>__repr__</code>, <code>__eq__</code>, and serialization.</p> <ul> <li>Pros: Full control, no dependencies</li> <li>Cons: Significant boilerplate, error-prone, no serialization support, manual validation required</li> <li>Reason for rejection: Too much maintenance burden for functionality that Pydantic provides out-of-the-box</li> </ul>"},{"location":"adr/0001-pydantic-for-data-models/#future-direction","title":"Future Direction","text":"<p>Enables file-based cassette storage and schema generation for documentation.</p> <p>Revisit if Pydantic's dependency footprint or validation overhead becomes problematic.</p>"},{"location":"adr/0001-pydantic-for-data-models/#references","title":"References","text":"<ul> <li>Pydantic Documentation</li> <li>Pydantic Performance</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/","title":"ADR 0002: Use SHA-256 for Request Fingerprinting","text":""},{"location":"adr/0002-sha256-fingerprinting/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0002-sha256-fingerprinting/#date","title":"Date","text":"<p>2026-01-05</p>"},{"location":"adr/0002-sha256-fingerprinting/#context","title":"Context","text":"<p>The replay system needs to match incoming requests against recorded interactions. This requires a stable, deterministic fingerprinting mechanism that uniquely identifies requests based on their protocol, action, target, headers, and body content. The fingerprint must be consistent across different processes and Python sessions.</p>"},{"location":"adr/0002-sha256-fingerprinting/#decision","title":"Decision","text":"<p>Use SHA-256 hashing with canonical JSON serialization for request fingerprinting. The canonical representation is generated by serializing a list of request fields <code>[protocol, action, target, headers, body_hex]</code> using <code>json.dumps</code> with <code>separators=(\",\", \":\")</code> and <code>sort_keys=True</code> to ensure determinism and prevent delimiter collisions. Header ordering is preserved (no normalization).</p>"},{"location":"adr/0002-sha256-fingerprinting/#rationale","title":"Rationale","text":"<ul> <li>Stability: Hash-based fingerprints are deterministic and consistent across processes</li> <li>Collision resistance: SHA-256 combined with structure-preserving JSON serialization prevents accidental collisions (e.g., when fields contain the delimiter)</li> <li>Standard library: Available in Python's <code>hashlib</code> and <code>json</code> without external dependencies</li> <li>Canonical ordering: Fixed JSON separators ensure identical requests produce identical fingerprints regardless of environment without normalizing request data</li> <li>Binary-safe: Hex-encoded body in JSON handles arbitrary binary data safely</li> <li>Compact: Fixed-length 64-character hex digest is memory-efficient</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/#implications","title":"Implications","text":""},{"location":"adr/0002-sha256-fingerprinting/#positive-implications","title":"Positive Implications","text":"<ul> <li>Fingerprints are stable across application restarts and different machines</li> <li>O(1) lookup using fingerprints as dictionary keys</li> <li>No false positives from hash collisions in realistic scenarios</li> <li>Header order affects matching (no normalization)</li> <li>Works with any protocol (protocol-agnostic design)</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/#concerns","title":"Concerns","text":"<ul> <li>Hash computation has O(n) cost proportional to request size (mitigation: acceptable for typical request sizes)</li> <li>Changing canonical format breaks compatibility with existing cassettes (mitigation: version 0 is in-memory only)</li> <li>Cryptographic hashing may be overkill for this use case (mitigation: no measurable performance impact)</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/#alternatives","title":"Alternatives","text":""},{"location":"adr/0002-sha256-fingerprinting/#direct-request-comparison-__eq__","title":"Direct Request Comparison (<code>__eq__</code>)","text":"<p>Using direct object equality comparison to find matching requests.</p> <ul> <li>Pros: Simple implementation, no hashing overhead</li> <li>Cons: O(n) lookup time for finding interactions in cassette, cannot use requests as dictionary keys without stable hash</li> <li>Reason for rejection: Poor performance for large cassettes; O(n) lookup vs O(1) with hash-based index</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/#md5-hashing","title":"MD5 Hashing","text":"<p>Using MD5 hash algorithm for fingerprinting.</p> <ul> <li>Pros: Faster than SHA-256, sufficient for non-cryptographic use</li> <li>Cons: Considered cryptographically broken, community perception of MD5 weakness could undermine trust</li> <li>Reason for rejection: Reputational risk outweighs marginal performance gains</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/#non-cryptographic-hashes-xxhash-murmurhash","title":"Non-cryptographic Hashes (xxHash, MurmurHash)","text":"<p>Using fast non-cryptographic hash algorithms like xxHash or MurmurHash.</p> <ul> <li>Pros: Faster than SHA-256, designed for hash table use</li> <li>Cons: Requires external dependency, not in standard library, adds maintenance burden</li> <li>Reason for rejection: Performance difference is negligible for this use case; standard library preference</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/#tuple-based-keys","title":"Tuple-based Keys","text":"<p>Using tuples of request fields directly as dictionary keys.</p> <ul> <li>Pros: No hashing overhead, direct comparison</li> <li>Cons: Large memory footprint for storing full request data as keys</li> <li>Reason for rejection: Memory inefficient; stable hashing provides compact keys</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/#future-direction","title":"Future Direction","text":"<p>This decision should be revisited if:</p> <ul> <li>Performance profiling shows hashing is a bottleneck (consider faster non-cryptographic hashes)</li> <li>Large request bodies cause excessive memory pressure (consider streaming hash calculation without full in-memory loading)</li> <li>Cassette persistence is added and backward compatibility becomes critical (use versioning scheme)</li> <li>Protocol-specific fingerprinting is needed (extend with pluggable fingerprint strategies)</li> <li>Matching rules need to be customized (make fingerprinting + matching strategy injectable, including hash choice)</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/#references","title":"References","text":"<ul> <li>Python hashlib documentation</li> <li>SHA-256 specification</li> </ul>"},{"location":"adr/0003-generator-streaming/","title":"ADR 0003: Use Generator Pattern for Response Streaming","text":""},{"location":"adr/0003-generator-streaming/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0003-generator-streaming/#date","title":"Date","text":"<p>2026-01-05</p>"},{"location":"adr/0003-generator-streaming/#context","title":"Context","text":"<p>The replay system needs to deliver response chunks to consumers. Responses may consist of multiple chunks that should be delivered in sequence. The library must support both small responses (single chunk) and potentially large responses (many chunks) without excessive memory usage.</p>"},{"location":"adr/0003-generator-streaming/#decision","title":"Decision","text":"<p>Use Python generators (<code>Iterator[ResponseChunk]</code>) for streaming response chunks. The <code>Broker.replay()</code> method returns an iterator that yields chunks lazily.</p>"},{"location":"adr/0003-generator-streaming/#rationale","title":"Rationale","text":"<ul> <li>Memory efficiency: Chunks are yielded one at a time, avoiding loading entire response into memory</li> <li>Lazy evaluation: Consumers can process chunks as they arrive, enabling streaming workflows</li> <li>Pythonic: Generator pattern is idiomatic Python for sequential data</li> <li>Composable: Generators can be chained, filtered, or transformed using standard itertools</li> <li>Backpressure: Consumer controls iteration pace, natural flow control</li> <li>Testable: Easy to collect into list for testing (<code>list(broker.replay(request))</code>)</li> </ul>"},{"location":"adr/0003-generator-streaming/#implications","title":"Implications","text":""},{"location":"adr/0003-generator-streaming/#positive-implications","title":"Positive Implications","text":"<ul> <li>Scales to arbitrarily large responses without memory pressure</li> <li>Natural fit for streaming protocols (HTTP chunked encoding, gRPC streaming, etc.)</li> <li>Consumers can process chunks incrementally (progress indicators, real-time processing)</li> <li>Simple implementation using <code>yield from interaction.response_chunks</code></li> <li>Clear iteration boundary (StopIteration signals completion)</li> </ul>"},{"location":"adr/0003-generator-streaming/#concerns","title":"Concerns","text":"<ul> <li>Consumers must iterate to completion with no random access to middle chunks (mitigation: acceptable tradeoff for memory efficiency)</li> <li>Generator state cannot be reset for re-iteration (mitigation: call <code>replay()</code> again to get new generator)</li> <li>Error handling requires try/except around iteration, not just the initial call (mitigation: standard Python pattern for iterators)</li> <li>Some consumers may prefer materialized list (mitigation: use <code>list()</code> wrapper when needed)</li> </ul>"},{"location":"adr/0003-generator-streaming/#alternatives","title":"Alternatives","text":""},{"location":"adr/0003-generator-streaming/#return-tuple-of-chunks","title":"Return Tuple of Chunks","text":"<p>Returning all chunks as a tuple immediately.</p> <ul> <li>Pros: Simpler for consumers that need all chunks upfront, immutable collection</li> <li>Cons: Entire response must be loaded into memory before returning, no memory savings for large responses</li> <li>Reason for rejection: Defeats purpose of streaming; memory inefficient for large responses</li> </ul>"},{"location":"adr/0003-generator-streaming/#return-list-of-chunks","title":"Return List of Chunks","text":"<p>Returning all chunks as a list immediately.</p> <ul> <li>Pros: Familiar collection type, random access support</li> <li>Cons: Same memory concerns as tuple, mutable return type contradicts immutability principle</li> <li>Reason for rejection: Memory inefficiency plus mutability concerns</li> </ul>"},{"location":"adr/0003-generator-streaming/#async-generator-asynciteratorresponsechunk","title":"Async Generator (<code>AsyncIterator[ResponseChunk]</code>)","text":"<p>Using async generators for streaming chunks.</p> <ul> <li>Pros: Natural fit for I/O-bound operations, enables concurrent processing</li> <li>Cons: Adds complexity without clear benefit for in-memory replay, forces async/await on all consumers</li> <li>Reason for rejection: Unnecessary complexity for in-memory cassettes; consider for future I/O-based backends</li> </ul>"},{"location":"adr/0003-generator-streaming/#callback-based-api","title":"Callback-based API","text":"<p>Using callback functions to deliver chunks (e.g., <code>replay(request, on_chunk=callback)</code>).</p> <ul> <li>Pros: Familiar pattern from JavaScript, enables push-based flow</li> <li>Cons: Less Pythonic, harder to compose, inverted control flow is harder to test, no natural backpressure mechanism</li> <li>Reason for rejection: Generators provide better ergonomics and testability in Python</li> </ul>"},{"location":"adr/0003-generator-streaming/#future-direction","title":"Future Direction","text":"<p>This decision should be revisited if:</p> <ul> <li>Async I/O support is added (consider <code>AsyncIterator[ResponseChunk]</code>)</li> <li>Profiling shows generator overhead is measurable (unlikely)</li> <li>Random access to chunks is frequently needed (consider hybrid approach with optional materialization)</li> </ul>"},{"location":"adr/0003-generator-streaming/#references","title":"References","text":"<ul> <li>PEP 255 - Simple Generators</li> <li>Python Iterator Protocol</li> </ul>"},{"location":"adr/0004-first-match-strategy/","title":"ADR 0004: Use First-Match Strategy for Duplicate Interactions","text":""},{"location":"adr/0004-first-match-strategy/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0004-first-match-strategy/#date","title":"Date","text":"<p>2026-01-05</p>"},{"location":"adr/0004-first-match-strategy/#context","title":"Context","text":"<p>A cassette may contain multiple interactions with identical request fingerprints (same protocol, action, target, headers, and body) but different responses. This can occur when recording non-deterministic endpoints or capturing time-series data. The replay system must define which interaction to return when multiple matches exist.</p>"},{"location":"adr/0004-first-match-strategy/#decision","title":"Decision","text":"<p>Always return the first matching interaction when multiple interactions share the same fingerprint. Subsequent matches are ignored during replay.</p>"},{"location":"adr/0004-first-match-strategy/#rationale","title":"Rationale","text":"<ul> <li>Determinism: First-match guarantees consistent behavior across replay sessions</li> <li>Simplicity: No complex selection logic or state tracking required</li> <li>Testability: Easy to verify behavior with duplicate interactions</li> <li>Predictability: Insertion order (recording order) determines replay order</li> <li>O(1) performance: First-match enables simple index-based lookup (see ADR 0005)</li> <li>Clear semantics: \"First recorded, first replayed\" is intuitive</li> </ul>"},{"location":"adr/0004-first-match-strategy/#implications","title":"Implications","text":""},{"location":"adr/0004-first-match-strategy/#positive-implications","title":"Positive Implications","text":"<ul> <li>Deterministic replay behavior simplifies debugging</li> <li>Implementation is trivial (index stores first occurrence)</li> <li>No need for match counters or stateful replay logic</li> <li>Clear contract: cassette creation order matters</li> <li>Works naturally with append-only recording workflows</li> </ul>"},{"location":"adr/0004-first-match-strategy/#concerns","title":"Concerns","text":"<ul> <li>Subsequent duplicate interactions are silently ignored (mitigation: intentional design for simplicity; users can filter cassettes if needed)</li> <li>No built-in support for stateful replay sequences (mitigation: can be layered on top with StatefulBroker wrapper in future)</li> <li>Users cannot specify which duplicate to use without cassette manipulation (mitigation: cassette ordering is under user control)</li> <li>Order dependency may surprise users expecting round-robin or random selection (mitigation: documented behavior; first-match is intuitive)</li> </ul>"},{"location":"adr/0004-first-match-strategy/#alternatives","title":"Alternatives","text":""},{"location":"adr/0004-first-match-strategy/#all-match-return-iterator-of-all-matches","title":"All-Match (Return Iterator of All Matches)","text":"<p>Returning an iterator of all matching interactions instead of a single match.</p> <ul> <li>Pros: Preserves all recorded data</li> <li>Cons: Unclear which response to use for a single replay, forces complexity onto consumers</li> <li>Reason for rejection: Does not solve the fundamental question of which response to use; pushes decision-making burden onto every consumer</li> </ul>"},{"location":"adr/0004-first-match-strategy/#round-robin-strategy","title":"Round-Robin Strategy","text":"<p>Cycling through matching interactions on successive calls.</p> <ul> <li>Pros: Could model stateful interactions</li> <li>Cons: Requires mutable state in Broker (violates immutability principle), non-deterministic across different broker instances</li> <li>Reason for rejection: Breaks immutability guarantees and makes replay behavior unpredictable when using multiple broker instances</li> </ul>"},{"location":"adr/0004-first-match-strategy/#random-selection","title":"Random Selection","text":"<p>Randomly selecting one of the matching interactions.</p> <ul> <li>Pros: Simple to implement</li> <li>Cons: Non-deterministic makes testing harder, no clear use case for this behavior, violates principle of predictable replay</li> <li>Reason for rejection: Non-determinism is fundamentally incompatible with the goal of reproducible test fixtures</li> </ul>"},{"location":"adr/0004-first-match-strategy/#raise-error-on-duplicates","title":"Raise Error on Duplicates","text":"<p>Throwing an error when duplicate fingerprints are detected in a cassette.</p> <ul> <li>Pros: Makes order dependency explicit</li> <li>Cons: Too strict, prevents legitimate recording scenarios, forces users to deduplicate cassettes manually</li> <li>Reason for rejection: Overly restrictive; duplicates are legitimate in real-world recording (non-deterministic endpoints, time-series data)</li> </ul>"},{"location":"adr/0004-first-match-strategy/#last-match-strategy","title":"Last-Match Strategy","text":"<p>Returning the last matching interaction instead of the first.</p> <ul> <li>Pros: Simple to implement</li> <li>Cons: Counter-intuitive (why record earlier interactions if they're ignored?), no advantage over first-match</li> <li>Reason for rejection: No meaningful benefit over first-match while being less intuitive about why earlier recordings exist</li> </ul>"},{"location":"adr/0004-first-match-strategy/#future-direction","title":"Future Direction","text":"<p>This decision should be revisited if:</p> <ul> <li>Stateful replay (consuming interactions on use) is needed (add explicit mode or new Broker type)</li> <li>Users frequently need round-robin behavior (consider StatefulBroker wrapper)</li> <li>Duplicate detection is required (add validation utility, not core behavior)</li> <li>Complex matching strategies are needed (introduce pluggable strategy pattern)</li> <li>Matching strategy becomes pluggable (keep first-match as the default when duplicates occur)</li> </ul> <p>Use first-match as the foundation. More complex strategies can be layered on top without changing the core behavior.</p>"},{"location":"adr/0004-first-match-strategy/#references","title":"References","text":"<ul> <li>VCR.rb uses first-match by default for duplicate cassettes</li> <li>WireMock uses priority-based matching (more complex, rejected for v0)</li> </ul>"},{"location":"adr/0005-cassette-index/","title":"ADR 0005: Build Fingerprint Index for O(1) Lookup","text":""},{"location":"adr/0005-cassette-index/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0005-cassette-index/#date","title":"Date","text":"<p>2026-01-05</p>"},{"location":"adr/0005-cassette-index/#context","title":"Context","text":"<p>The cassette stores interactions as a tuple and needs to find interactions matching a given request fingerprint. Without an index, finding a match requires linear search (O(n)) through all interactions. For large cassettes with hundreds or thousands of interactions, this becomes a performance bottleneck.</p>"},{"location":"adr/0005-cassette-index/#decision","title":"Decision","text":"<p>Build a <code>dict[RequestFingerprint, int]</code> index at cassette construction that maps fingerprints to their first occurrence position in the interactions tuple. The index is built using a model validator and stored as a private attribute.</p>"},{"location":"adr/0005-cassette-index/#rationale","title":"Rationale","text":"<ul> <li>O(1) lookup: Dictionary lookup is constant time, vastly superior to O(n) linear search</li> <li>Initialization cost: Index is built once during cassette creation, amortized over many lookups</li> <li>Memory efficiency: Index stores only integers (positions), not duplicate interaction data</li> <li>First-match alignment: Index naturally stores first occurrence, implementing ADR 0004</li> <li>Immutable after creation: Index is built during construction and never modified</li> <li>Transparent: Implementation detail hidden from users (private attribute)</li> </ul>"},{"location":"adr/0005-cassette-index/#implications","title":"Implications","text":""},{"location":"adr/0005-cassette-index/#positive-implications","title":"Positive Implications","text":"<ul> <li>Replay performance is independent of cassette size (O(1) vs O(n))</li> <li>Enables large cassettes (thousands of interactions) without performance degradation</li> <li>Simple implementation using standard library dict</li> <li>Index construction is deterministic and testable</li> <li>Memory overhead is minimal (one int per unique fingerprint)</li> </ul>"},{"location":"adr/0005-cassette-index/#concerns","title":"Concerns","text":"<ul> <li>Upfront cost to build index during cassette creation (mitigation: acceptable one-time cost amortized over many lookups)</li> <li>Uses <code>object.__setattr__</code> to mutate frozen model (mitigation: required for immutability, Pydantic pattern for private attributes)</li> <li>Memory overhead for the index dict (mitigation: minimal, ~8 bytes per unique fingerprint)</li> <li>Index is not exposed in serialization or repr (mitigation: intentional design, private implementation detail)</li> </ul>"},{"location":"adr/0005-cassette-index/#alternatives","title":"Alternatives","text":""},{"location":"adr/0005-cassette-index/#linear-search-no-index","title":"Linear Search (No Index)","text":"<p>Finding interactions by iterating through the tuple without an index.</p> <ul> <li>Pros: No memory overhead, simpler implementation</li> <li>Cons: O(n) lookup time becomes bottleneck for large cassettes, performance degrades proportionally with cassette size</li> <li>Reason for rejection: Performance is unacceptable for production use with large cassettes (hundreds or thousands of interactions)</li> </ul>"},{"location":"adr/0005-cassette-index/#build-index-on-first-lookup-lazy-initialization","title":"Build Index on First Lookup (Lazy Initialization)","text":"<p>Deferring index construction until the first lookup call.</p> <ul> <li>Pros: Defers cost if cassette is never used</li> <li>Cons: Requires mutable state to track \"index built\" flag, violates frozen model immutability principle</li> <li>Reason for rejection: Breaks immutability guarantees; construction-time indexing is simpler and aligns with frozen model design</li> </ul>"},{"location":"adr/0005-cassette-index/#external-index-separate-data-structure","title":"External Index (Separate Data Structure)","text":"<p>Maintaining the index as a separate object outside the cassette.</p> <ul> <li>Pros: Clear separation of concerns</li> <li>Cons: Requires managing two objects (cassette + index) in sync, more complex API (users must pass both), risk of desynchronization if index is mutated</li> <li>Reason for rejection: API complexity and synchronization risk outweigh benefits; internal index is simpler and safer</li> </ul>"},{"location":"adr/0005-cassette-index/#use-list-instead-of-tuple-for-interactions","title":"Use List Instead of Tuple for Interactions","text":"<p>Storing interactions in a mutable list to enable direct mutation.</p> <ul> <li>Pros: No workaround needed for frozen models</li> <li>Cons: Mutable collection contradicts immutability principle, no advantage for index-based access (tuple supports indexing)</li> <li>Reason for rejection: Immutability is a core design principle; tuple is the correct choice for frozen data</li> </ul>"},{"location":"adr/0005-cassette-index/#store-interactions-in-dict-no-tuple","title":"Store Interactions in Dict (No Tuple)","text":"<p>Using a dict mapping fingerprints to interactions directly, eliminating the tuple.</p> <ul> <li>Pros: Built-in O(1) lookup without separate index</li> <li>Cons: Loses insertion order for duplicates (violates ADR 0004), cannot represent multiple interactions with same fingerprint, fundamentally different data model</li> <li>Reason for rejection: Incompatible with first-match strategy; duplicates are legitimate and must be preserved in order</li> </ul>"},{"location":"adr/0005-cassette-index/#future-direction","title":"Future Direction","text":"<p>This decision should be revisited if:</p> <ul> <li>Profiling shows index build time is a bottleneck (unlikely, dict insert is fast)</li> <li>Memory pressure from large indexes becomes an issue (consider specialized data structures)</li> <li>Alternative frozen dataclass patterns emerge (Python 3.13+ features)</li> <li>Cassette persistence requires serializing/deserializing the index (versioning strategy needed)</li> <li>Matching strategy becomes pluggable (index should be built from the configured fingerprinting strategy)</li> </ul>"},{"location":"adr/0005-cassette-index/#references","title":"References","text":"<ul> <li>Python dict implementation</li> <li>Dataclass frozen=True documentation</li> <li>Big-O Complexity of Python Operations</li> </ul>"},{"location":"adr/0006-external-adapters/","title":"ADR 0006: External Protocol Adapters Strategy","text":""},{"location":"adr/0006-external-adapters/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0006-external-adapters/#date","title":"Date","text":"<p>2026-01-10</p>"},{"location":"adr/0006-external-adapters/#context","title":"Context","text":"<p>Interposition is designed to be a protocol-agnostic logic engine for recording and replaying interactions.</p> <p>Users integrate Interposition with various consumers. These include:</p> <ul> <li>Python libraries: e.g., <code>requests</code>, <code>psycopg2</code>, <code>boto3</code>.</li> <li>External processes: e.g., <code>curl</code> commands, <code>psql</code> clients, or applications written in other languages (Node.js, Go).</li> </ul> <p>A key architectural decision is whether to include specific adapters for these use cases within the core <code>interposition</code> package or to keep them separate.</p>"},{"location":"adr/0006-external-adapters/#decision","title":"Decision","text":"<p>We will NOT include protocol-specific adapters in the core <code>interposition</code> package.</p> <p>Adapters must be:</p> <ol> <li>Implemented by the user or provided as separate packages.</li> <li>Capable of using the strategy best suited for the target (e.g., Monkey Patching for simple Python unit tests, Proxy Servers for black-box E2E tests).</li> </ol> <p>The core package will remain a pure logic engine with minimal dependencies.</p>"},{"location":"adr/0006-external-adapters/#rationale","title":"Rationale","text":"<ul> <li>Diverse Integration Strategies: Different contexts require different integration methods. A unit test might prefer a lightweight monkey patch on <code>requests</code>, while an E2E test requires a transparent HTTP proxy to intercept traffic from a subprocess. The core engine should not dictate the integration strategy.</li> <li>Separation of Concerns: Interposition handles what to replay. The Adapter handles how to intercept it.</li> <li>Dependency Management: Including adapters for every possible library and protocol would bloat the core package.</li> <li>Release Independence: The core engine should not need updates when external libraries change.</li> </ul>"},{"location":"adr/0006-external-adapters/#implications","title":"Implications","text":""},{"location":"adr/0006-external-adapters/#positive-implications","title":"Positive Implications","text":"<ul> <li>Flexibility: Users can choose to implement a Proxy, a Monkey Patch, or a Decorator based on their testing needs.</li> <li>Lightweight Core: <code>pip install interposition</code> remains small and fast.</li> <li>E2E Support: Explicitly designing for \"external adapters\" encourages the creation of proxy-based tools that enable language-agnostic testing.</li> </ul>"},{"location":"adr/0006-external-adapters/#concerns","title":"Concerns","text":"<ul> <li>Onboarding Friction: Users need to write glue code to get started (Mitigation: Provide high-quality \"Reference Implementations\" in <code>examples/</code> for both strategies, e.g., a <code>requests</code> patcher AND a simple HTTP proxy).</li> </ul>"},{"location":"adr/0006-external-adapters/#alternatives","title":"Alternatives","text":""},{"location":"adr/0006-external-adapters/#include-common-adapters-eg-requests-in-core","title":"Include Common Adapters (e.g., <code>requests</code>) in Core","text":"<p>Include adapters for the most popular libraries (like <code>requests</code>) in the main package.</p> <ul> <li>Pros: Easier onboarding for the majority of users.</li> <li>Cons: Increases maintenance burden and dependency graph.</li> <li>Reason for Rejection: Violates the strict separation of concerns.</li> </ul>"},{"location":"adr/0006-external-adapters/#monorepo-with-multiple-packages","title":"Monorepo with Multiple Packages","text":"<p>Manage core and adapters in a single monorepo but publish them as separate PyPI packages (<code>interposition</code>, <code>interposition-requests</code>, etc.).</p> <ul> <li>Pros: Centralized management, separate dependencies.</li> <li>Cons: Higher complexity in CI/CD and release processes.</li> <li>Reason for Rejection: Premature complexity. We will start with Reference Implementations and consider separate packages if demand grows.</li> </ul>"},{"location":"adr/0006-external-adapters/#future-direction","title":"Future Direction","text":"<p>We will create an <code>examples/</code> directory to house high-quality reference adapters. If a specific adapter becomes extremely popular and stable, we may consider adopting it as an official separate package (e.g., <code>interposition-requests</code>) under the same organization, but it will remain distinct from the core.</p>"},{"location":"adr/0006-external-adapters/#references","title":"References","text":"<ul> <li>OpenTelemetry Architecture (Separation of API/SDK from Instrumentation)</li> </ul>"},{"location":"adr/0007-broker-mode-parameter/","title":"ADR 0007: Broker Mode Parameter for Record Functionality","text":""},{"location":"adr/0007-broker-mode-parameter/#status","title":"Status","text":"<p>Accepted (Amended 2026-01-30)</p>"},{"location":"adr/0007-broker-mode-parameter/#date","title":"Date","text":"<p>2026-01-25</p>"},{"location":"adr/0007-broker-mode-parameter/#context","title":"Context","text":"<p>Interposition currently supports only replay mode. The Broker looks up interactions by fingerprint and returns recorded responses. When a MISS occurs, it raises <code>InteractionNotFoundError</code>.</p> <p>To support recording functionality, the Broker needs to handle MISS differently depending on the intended use case:</p> <ul> <li>Replay mode: MISS should raise an error (current behavior).</li> <li>Record mode: MISS should forward to a live upstream and record the response.</li> <li>Auto mode: HIT should replay, MISS should forward and record.</li> </ul> <p>The question is how to represent this behavioral variation.</p>"},{"location":"adr/0007-broker-mode-parameter/#decision","title":"Decision","text":"<p>Add a <code>mode</code> parameter to the Broker class that determines MISS handling behavior.</p> <p>The mode is set at Broker construction time and remains constant for the lifetime of the Broker instance.</p>"},{"location":"adr/0007-broker-mode-parameter/#rationale","title":"Rationale","text":"<ul> <li>Single entry point: Users interact with one Broker class rather than multiple classes (ReplayBroker, RecordBroker, etc.).</li> <li>Explicit configuration: The mode is visible in the constructor, making behavior predictable.</li> <li>Backward compatible: Default mode is \"replay\", preserving existing behavior.</li> <li>Testable: Mode can be easily switched in tests without changing other setup.</li> </ul>"},{"location":"adr/0007-broker-mode-parameter/#implications","title":"Implications","text":""},{"location":"adr/0007-broker-mode-parameter/#positive-implications","title":"Positive Implications","text":"<ul> <li>Simple API: <code>Broker(cassette, mode=\"auto\")</code>.</li> <li>Clear behavioral contract per mode.</li> <li>Easy to extend with additional modes if needed.</li> </ul>"},{"location":"adr/0007-broker-mode-parameter/#concerns","title":"Concerns","text":"<ul> <li>Mode validation is static only; runtime validation is not enforced by default (mitigation: rely on type checking and clear documentation).</li> <li>Mode affects multiple methods' behavior (mitigation: document clearly, keep logic localized).</li> </ul>"},{"location":"adr/0007-broker-mode-parameter/#alternatives","title":"Alternatives","text":""},{"location":"adr/0007-broker-mode-parameter/#separate-classes-replaybroker-recordbroker","title":"Separate Classes (ReplayBroker, RecordBroker)","text":"<p>Create distinct classes for each mode.</p> <ul> <li>Pros: Single Responsibility Principle, no conditional logic.</li> <li>Cons: Code duplication, users must choose correct class, harder to switch modes.</li> <li>Reason for rejection: The core logic (fingerprinting, cassette lookup) is shared across modes. Separate classes would duplicate this logic.</li> </ul>"},{"location":"adr/0007-broker-mode-parameter/#method-parameter","title":"Method Parameter","text":"<p>Pass mode to each method call: <code>broker.handle(request, mode=\"record\")</code>.</p> <ul> <li>Pros: Flexible per-request behavior.</li> <li>Cons: Verbose, error-prone, inconsistent behavior within same broker instance.</li> <li>Reason for rejection: Mode should be a broker-level concern, not a per-request concern.</li> </ul>"},{"location":"adr/0007-broker-mode-parameter/#strategy-pattern","title":"Strategy Pattern","text":"<p>Inject a mode strategy object into Broker.</p> <ul> <li>Pros: Extensible, testable strategies.</li> <li>Cons: Over-engineered for three simple modes, additional abstraction layer.</li> <li>Reason for rejection: Premature abstraction. A simple parameter suffices for the current requirements.</li> </ul>"},{"location":"adr/0007-broker-mode-parameter/#future-direction","title":"Future Direction","text":"<p>Revisit if:</p> <ul> <li>Modes require significantly different initialization (e.g., different dependencies).</li> <li>Per-request mode switching becomes a requirement.</li> <li>The number of modes grows beyond what a simple parameter can handle.</li> </ul>"},{"location":"adr/0007-broker-mode-parameter/#references","title":"References","text":"<ul> <li>Issue #5: Record mode feature request</li> </ul>"},{"location":"adr/0007-broker-mode-parameter/#amendment-2026-01-30","title":"Amendment (2026-01-30)","text":""},{"location":"adr/0007-broker-mode-parameter/#what-changed","title":"What Changed","text":"<p>Corrected the earlier MISS-only phrasing for record mode. Record mode always forwards to live and records, even on HIT, to distinguish it from auto mode.</p>"},{"location":"adr/0007-broker-mode-parameter/#reason-for-amendment","title":"Reason for Amendment","text":"<p>The original text implied record mode only forwarded on MISS, which conflicts with the implemented behavior. Record mode is a forced-refresh workflow, while auto mode remains cache-friendly.</p>"},{"location":"adr/0007-broker-mode-parameter/#impact-on-original-adr","title":"Impact on Original ADR","text":"<p>Unchanged:</p> <ul> <li>Broker has a mode parameter with replay/record/auto values.</li> <li>auto mode replays on HIT and forwards on MISS.</li> <li>replay mode raises on MISS.</li> </ul> <p>Changed:</p> <ul> <li>record mode is explicitly defined as always forwarding and recording.</li> </ul>"},{"location":"adr/0008-literal-type-for-broker-mode/","title":"ADR 0008: Use Literal Type for Broker Mode Values","text":""},{"location":"adr/0008-literal-type-for-broker-mode/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0008-literal-type-for-broker-mode/#date","title":"Date","text":"<p>2026-01-25</p>"},{"location":"adr/0008-literal-type-for-broker-mode/#context","title":"Context","text":"<p>ADR 0007 introduced a mode parameter to the Broker class. The mode accepts one of three string values: \"replay\", \"record\", or \"auto\".</p> <p>The mode value must be type-safe and provide good developer experience. Two approaches are available in Python for representing a fixed set of string values:</p> <ol> <li><code>typing.Literal[\"replay\", \"record\", \"auto\"]</code></li> <li><code>enum.Enum</code> subclass (e.g., <code>class BrokerMode(str, Enum)</code>)</li> </ol>"},{"location":"adr/0008-literal-type-for-broker-mode/#decision","title":"Decision","text":"<p>Use <code>typing.Literal</code> with a type alias for the broker mode.</p>"},{"location":"adr/0008-literal-type-for-broker-mode/#rationale","title":"Rationale","text":"<ul> <li>Consistency with typing-first design: Literal types integrate with mypy and keep the API lightweight without extra runtime machinery.</li> <li>Simplicity: Literal types require no class definition, reducing boilerplate.</li> <li>String compatibility: Literal values are plain strings, making serialization trivial and API usage straightforward.</li> <li>Type safety: Both approaches provide equivalent static type checking via mypy.</li> </ul>"},{"location":"adr/0008-literal-type-for-broker-mode/#implications","title":"Implications","text":""},{"location":"adr/0008-literal-type-for-broker-mode/#positive-implications","title":"Positive Implications","text":"<ul> <li>Mode values can be passed as plain strings without imports.</li> <li>JSON serialization works without custom encoders.</li> <li>Less code to maintain.</li> </ul>"},{"location":"adr/0008-literal-type-for-broker-mode/#concerns","title":"Concerns","text":"<ul> <li>IDE autocompletion may be slightly less discoverable than Enum members (mitigation: type alias makes the valid values explicit in documentation and type hints).</li> <li>No runtime validation by default (mitigation: rely on static type checking and clear documentation).</li> </ul>"},{"location":"adr/0008-literal-type-for-broker-mode/#alternatives","title":"Alternatives","text":""},{"location":"adr/0008-literal-type-for-broker-mode/#enum-type","title":"Enum Type","text":"<p>Using <code>class BrokerMode(str, Enum): REPLAY = \"replay\" ...</code></p> <ul> <li>Pros: Strong IDE autocompletion, explicit namespace for values, runtime validation built-in.</li> <li>Cons: Requires import, additional boilerplate, serialization needs <code>.value</code> access.</li> <li>Reason for rejection: The additional ceremony does not provide sufficient benefit for this use case.</li> </ul>"},{"location":"adr/0008-literal-type-for-broker-mode/#future-direction","title":"Future Direction","text":"<p>Revisit if:</p> <ul> <li>Mode values need associated behavior (methods on the enum).</li> <li>Runtime validation outside Pydantic becomes necessary.</li> <li>The number of modes grows significantly.</li> </ul>"},{"location":"adr/0008-literal-type-for-broker-mode/#references","title":"References","text":"<ul> <li>ADR 0007: Broker Mode Parameter for Record Functionality</li> <li>typing.Literal documentation</li> <li>Pydantic Literal types</li> </ul>"},{"location":"adr/0009-live-responder-port/","title":"ADR 0009: LiveResponder Port for Upstream Forwarding","text":""},{"location":"adr/0009-live-responder-port/#status","title":"Status","text":"<p>Accepted (Amended 2026-01-30)</p>"},{"location":"adr/0009-live-responder-port/#date","title":"Date","text":"<p>2026-01-25</p>"},{"location":"adr/0009-live-responder-port/#context","title":"Context","text":"<p>ADR 0007 introduced broker modes (replay, record, auto). In record and auto modes, when a MISS occurs (no matching interaction in cassette), the Broker must forward the request to a live upstream service and capture the response.</p> <p>The Broker needs a mechanism to communicate with the upstream, but per ADR 0006 (External Protocol Adapters), the core package must remain protocol-agnostic. The Broker cannot know how to make HTTP calls, database queries, or any protocol-specific operations.</p>"},{"location":"adr/0009-live-responder-port/#decision","title":"Decision","text":"<p>Define LiveResponder as a callable port that the user provides.</p> <p>The signature is: <code>Callable[[InteractionRequest], Iterable[ResponseChunk]]</code></p> <p>The Broker accepts an optional <code>live_responder</code> parameter at construction time.</p>"},{"location":"adr/0009-live-responder-port/#rationale","title":"Rationale","text":"<ul> <li>Protocol-agnostic: The Broker delegates upstream communication to user-provided code. The core library has no protocol dependencies.</li> <li>Simple interface: A callable is the simplest possible port. No abstract base classes or protocols required.</li> <li>Flexible return type: <code>Iterable[ResponseChunk]</code> supports both simple tuple returns and generator-based streaming.</li> <li>Optional dependency: <code>live_responder=None</code> means no upstream forwarding (pure replay mode behavior).</li> <li>Testable: Easy to mock in tests with a simple function.</li> <li>Composable: Multiple responders can be composed into one callable. Lifecycle management (setup/teardown) can be encapsulated in a class with <code>__call__</code>.</li> </ul>"},{"location":"adr/0009-live-responder-port/#implications","title":"Implications","text":""},{"location":"adr/0009-live-responder-port/#positive-implications","title":"Positive Implications","text":"<ul> <li>Zero protocol dependencies in core.</li> <li>Users have full control over upstream communication.</li> <li>Simple to implement for any protocol.</li> <li>Natural integration with existing client libraries.</li> </ul>"},{"location":"adr/0009-live-responder-port/#concerns","title":"Concerns","text":"<ul> <li>User must implement responder correctly (mitigation: provide examples, document contract clearly).</li> <li>Error handling is user's responsibility (mitigation: document expected behavior, recommend raising exceptions for failures).</li> </ul>"},{"location":"adr/0009-live-responder-port/#alternatives","title":"Alternatives","text":""},{"location":"adr/0009-live-responder-port/#abstract-base-class","title":"Abstract Base Class","text":"<p>Define <code>class LiveResponder(ABC)</code> with an abstract <code>respond</code> method.</p> <ul> <li>Pros: Explicit contract, IDE autocompletion on methods.</li> <li>Cons: More ceremony, users must subclass instead of just passing a function.</li> <li>Reason for rejection: Callable is simpler and sufficient. Python's duck typing makes ABC unnecessary.</li> </ul>"},{"location":"adr/0009-live-responder-port/#protocol-typingprotocol","title":"Protocol (typing.Protocol)","text":"<p>Define a structural protocol for type checking.</p> <ul> <li>Pros: Type safety without runtime overhead.</li> <li>Cons: Still more complex than a simple callable type alias.</li> <li>Reason for rejection: A callable type alias achieves the same goal with less complexity.</li> </ul>"},{"location":"adr/0009-live-responder-port/#future-direction","title":"Future Direction","text":"<p>Revisit if:</p> <ul> <li>Async support is added (consider <code>AsyncLiveResponder</code> type).</li> </ul>"},{"location":"adr/0009-live-responder-port/#references","title":"References","text":"<ul> <li>ADR 0006: External Protocol Adapters Strategy</li> <li>ADR 0007: Broker Mode Parameter for Record Functionality</li> </ul>"},{"location":"adr/0009-live-responder-port/#amendment-2026-01-30","title":"Amendment (2026-01-30)","text":""},{"location":"adr/0009-live-responder-port/#what-changed","title":"What Changed","text":"<p>Corrected an earlier ambiguous description of when forwarding occurs. Record mode always forwards to live, while auto mode forwards only on MISS.</p>"},{"location":"adr/0009-live-responder-port/#reason-for-amendment","title":"Reason for Amendment","text":"<p>The original text described forwarding only on MISS for both modes, which does not match the finalized record-mode behavior. The port definition remains unchanged; the clarification is about forwarding conditions.</p>"},{"location":"adr/0009-live-responder-port/#impact-on-original-adr","title":"Impact on Original ADR","text":"<p>Unchanged:</p> <ul> <li>LiveResponder remains a callable port with the same signature.</li> <li>Broker accepts an optional live_responder.</li> </ul> <p>Changed:</p> <ul> <li>Forwarding conditions are now explicitly tied to record vs. auto mode.</li> </ul>"},{"location":"adr/0010-record-buffering/","title":"ADR 0010: Buffer Live Responses Before Recording","text":""},{"location":"adr/0010-record-buffering/#status","title":"Status","text":"<p>Accepted (Amended 2026-01-30)</p>"},{"location":"adr/0010-record-buffering/#date","title":"Date","text":"<p>2026-01-25</p>"},{"location":"adr/0010-record-buffering/#context","title":"Context","text":"<p>Record/auto modes forward a MISS to a live responder and capture the response as an Interaction. The Broker previously streamed chunks as they arrived and recorded only after the consumer finished iterating.</p> <p>This behavior makes recording fragile: if the consumer stops early, the recording never completes and the cassette is left unchanged.</p>"},{"location":"adr/0010-record-buffering/#decision","title":"Decision","text":"<p>In record/auto mode on a MISS, fully collect the live response chunks before returning any data to the caller. After the full response is collected:</p> <ol> <li>Create the Interaction</li> <li>Append it to the cassette</li> <li>Yield the collected chunks</li> </ol>"},{"location":"adr/0010-record-buffering/#rationale","title":"Rationale","text":"<ul> <li>Recording integrity: The cassette is updated even if the consumer stops early.</li> <li>Determinism: Recording completes before any response is exposed.</li> <li>Validation: Interaction validation can run before the response is returned.</li> </ul>"},{"location":"adr/0010-record-buffering/#implications","title":"Implications","text":""},{"location":"adr/0010-record-buffering/#positive-implications","title":"Positive Implications","text":"<ul> <li>Reliable recording regardless of consumer behavior.</li> <li>Consistent cassette state after each replay call.</li> <li>Clearer error timing (validation failures occur before any data is returned).</li> </ul>"},{"location":"adr/0010-record-buffering/#concerns","title":"Concerns","text":"<ul> <li>Increased memory usage for large responses (mitigation: limit record mode to test fixtures or add size caps in a future policy).</li> <li>Additional latency before the first byte is returned in record/auto mode (mitigation: acceptable for record mode; replay mode remains streaming).</li> <li>Record path is no longer truly streaming (mitigation: introduce an opt-in streaming record path later if needed).</li> </ul>"},{"location":"adr/0010-record-buffering/#alternatives","title":"Alternatives","text":""},{"location":"adr/0010-record-buffering/#stream-then-record","title":"Stream Then Record","text":"<p>Yield chunks as they arrive and record after iteration completes.</p> <ul> <li>Pros: Minimal memory use, true streaming.</li> <li>Cons: Recording fails if the consumer stops early.</li> <li>Reason for rejection: Violates the requirement that recording should complete even when the consumer cancels early.</li> </ul>"},{"location":"adr/0010-record-buffering/#tee-stream-with-background-recording","title":"Tee Stream With Background Recording","text":"<p>Yield chunks immediately while a background task consumes and records the full stream.</p> <ul> <li>Pros: Streaming behavior with reliable recording.</li> <li>Cons: More complexity (threading/async), harder error handling, unclear lifecycle semantics.</li> <li>Reason for rejection: Too complex for v0; adds concurrency concerns to the core.</li> </ul>"},{"location":"adr/0010-record-buffering/#partial-recording","title":"Partial Recording","text":"<p>Persist only the chunks that were consumed by the caller.</p> <ul> <li>Pros: Keeps streaming, avoids buffering.</li> <li>Cons: Produces incomplete interactions, undermines replay determinism.</li> <li>Reason for rejection: Incomplete recordings are not acceptable for deterministic replay.</li> </ul>"},{"location":"adr/0010-record-buffering/#future-direction","title":"Future Direction","text":"<p>Revisit if:</p> <ul> <li>Large responses cause unacceptable memory pressure.</li> <li>Async APIs are introduced and background recording becomes feasible.</li> <li>A record policy needs to allow streaming with explicit \"best effort\" semantics.</li> </ul>"},{"location":"adr/0010-record-buffering/#references","title":"References","text":"<ul> <li>ADR 0007: Broker Mode Parameter for Record Functionality</li> <li>ADR 0009: LiveResponder Port for Upstream Forwarding</li> </ul>"},{"location":"adr/0010-record-buffering/#amendment-2026-01-30","title":"Amendment (2026-01-30)","text":""},{"location":"adr/0010-record-buffering/#what-changed","title":"What Changed","text":"<p>Corrected the earlier MISS-only framing. Buffering applies whenever forwarding occurs in record/auto mode, not only on MISS.</p>"},{"location":"adr/0010-record-buffering/#reason-for-amendment","title":"Reason for Amendment","text":"<p>The original text framed buffering as MISS-only, which is incorrect for record mode (always forward). Buffering must apply to any forward path to preserve recording integrity.</p>"},{"location":"adr/0010-record-buffering/#impact-on-original-adr","title":"Impact on Original ADR","text":"<p>Unchanged:</p> <ul> <li>Buffering is required before recording and returning responses.</li> <li>Trade-offs (memory/latency) remain the same.</li> </ul> <p>Changed:</p> <ul> <li>The trigger condition is \"any forward\" rather than \"MISS only.\"</li> </ul>"},{"location":"adr/0011-cassette-store-persistence-port/","title":"ADR 0011: CassetteStore Persistence Port","text":""},{"location":"adr/0011-cassette-store-persistence-port/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0011-cassette-store-persistence-port/#date","title":"Date","text":"<p>2026-01-30</p>"},{"location":"adr/0011-cassette-store-persistence-port/#context","title":"Context","text":"<p>Record and auto modes update the in-memory Cassette when new interactions are captured. However, there is no persistence mechanism\u2014recorded interactions are lost when the process ends.</p> <p>Users need a way to persist cassettes automatically, but per ADR 0006 (External Protocol Adapters), the core package must remain storage-agnostic. The Broker cannot assume file I/O, databases, cloud storage, or any specific persistence strategy.</p>"},{"location":"adr/0011-cassette-store-persistence-port/#decision","title":"Decision","text":"<p>Define CassetteStore as a Protocol port with two methods: <code>load()</code> and <code>save()</code>.</p> <p>The Broker accepts an optional <code>cassette_store</code> parameter at construction time. When configured, the Broker automatically calls <code>save()</code> after recording new interactions.</p> <p>A reference implementation <code>JsonFileCassetteStore</code> is provided in a separate module (<code>stores.py</code>) to keep JSON/filesystem logic out of core business logic.</p>"},{"location":"adr/0011-cassette-store-persistence-port/#rationale","title":"Rationale","text":"<ul> <li>Protocol over Callable: Unlike LiveResponder (single method), CassetteStore requires two methods (<code>load</code> and <code>save</code>). A Protocol provides a clear structural contract.</li> <li>Storage-agnostic: The Broker delegates persistence to user-provided code. The core library has no I/O dependencies.</li> <li>Auto-save on record: Automatically persisting after each recording simplifies the common use case. Users don't need to manually save after each interaction.</li> <li>Optional dependency: <code>cassette_store=None</code> means no automatic persistence (current behavior preserved).</li> <li>Separate module for implementation: <code>JsonFileCassetteStore</code> lives in <code>stores.py</code>, not <code>services.py</code>, keeping JSON serialization details out of the Broker.</li> </ul>"},{"location":"adr/0011-cassette-store-persistence-port/#implications","title":"Implications","text":""},{"location":"adr/0011-cassette-store-persistence-port/#positive-implications","title":"Positive Implications","text":"<ul> <li>Zero I/O dependencies in core business logic.</li> <li>Users can implement any persistence strategy (files, databases, cloud storage).</li> <li>Simple integration\u2014just pass a store to the Broker.</li> <li>Automatic saving reduces boilerplate for record/auto workflows.</li> <li>Pydantic's built-in serialization makes JSON implementation trivial.</li> </ul>"},{"location":"adr/0011-cassette-store-persistence-port/#concerns","title":"Concerns","text":"<ul> <li>Synchronous I/O may block during <code>save()</code> (mitigation: consider async variant in future).</li> <li>Save is called after each recording, which may be expensive for high-frequency recording (mitigation: users can implement buffered/batched stores).</li> <li>User must implement store correctly (mitigation: provide JsonFileCassetteStore as reference).</li> </ul>"},{"location":"adr/0011-cassette-store-persistence-port/#alternatives","title":"Alternatives","text":""},{"location":"adr/0011-cassette-store-persistence-port/#callable-for-save-only","title":"Callable for save only","text":"<p>Define <code>CassetteSaver = Callable[[Cassette], None]</code> for save-only functionality.</p> <ul> <li>Pros: Simpler, matches LiveResponder pattern.</li> <li>Cons: No <code>load()</code> method, users must manage loading separately.</li> <li>Reason for rejection: Having both <code>load()</code> and <code>save()</code> in one interface provides a cohesive persistence abstraction.</li> </ul>"},{"location":"adr/0011-cassette-store-persistence-port/#manual-save-only","title":"Manual save only","text":"<p>Require users to call <code>broker.cassette.model_dump_json()</code> manually.</p> <ul> <li>Pros: No new abstractions needed.</li> <li>Cons: Error-prone, users may forget to save after recording.</li> <li>Reason for rejection: Auto-save provides better user experience for the common case.</li> </ul>"},{"location":"adr/0011-cassette-store-persistence-port/#built-in-file-persistence-in-broker","title":"Built-in file persistence in Broker","text":"<p>Add file path parameter directly to Broker.</p> <ul> <li>Pros: Simpler API for file-based use case.</li> <li>Cons: Violates ADR 0006, couples core logic to filesystem.</li> <li>Reason for rejection: Broker should remain storage-agnostic.</li> </ul>"},{"location":"adr/0011-cassette-store-persistence-port/#future-direction","title":"Future Direction","text":"<p>Revisit if:</p> <ul> <li>Async support is added (consider <code>AsyncCassetteStore</code> Protocol).</li> <li>Lifecycle hooks are added (allow validation before save).</li> </ul>"},{"location":"adr/0011-cassette-store-persistence-port/#references","title":"References","text":"<ul> <li>ADR 0006: External Protocol Adapters Strategy</li> <li>ADR 0009: LiveResponder Port for Upstream Forwarding</li> </ul>"},{"location":"adr/0012-cassette-save-failure-behavior/","title":"ADR 0012: Cassette Save Failure Behavior","text":""},{"location":"adr/0012-cassette-save-failure-behavior/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0012-cassette-save-failure-behavior/#date","title":"Date","text":"<p>2026-01-31</p>"},{"location":"adr/0012-cassette-save-failure-behavior/#context","title":"Context","text":"<p>In record or auto mode, the Broker can be configured with a <code>CassetteStore</code> to persist newly recorded interactions. Save operations may fail due to I/O errors (permissions, disk full, etc.). The Broker must define how to behave when persistence fails while handling a request.</p> <p>The library's primary motivation is to stabilize nondeterministic API behavior for repeatable tests. If a recorded interaction cannot be persisted, future replays cannot rely on it.</p>"},{"location":"adr/0012-cassette-save-failure-behavior/#decision","title":"Decision","text":"<p>If saving a cassette fails, the error is propagated to the caller and the response stream does not continue. This is a fail-fast behavior.</p>"},{"location":"adr/0012-cassette-save-failure-behavior/#rationale","title":"Rationale","text":"<ul> <li>Reproducibility-first: A request that cannot be persisted undermines the core testing goal. Failing the current run surfaces the issue immediately.</li> <li>Consistency with evaluation: Users may evaluate responses and fail tests based on content; persistence failure is treated as an equally fatal error.</li> <li>Visibility: Suppressing persistence errors could hide issues and create false confidence in test stability.</li> </ul>"},{"location":"adr/0012-cassette-save-failure-behavior/#implications","title":"Implications","text":""},{"location":"adr/0012-cassette-save-failure-behavior/#positive-implications","title":"Positive Implications","text":"<ul> <li>Persistence failures are immediately visible.</li> <li>Test runs remain honest about what is actually reproducible.</li> </ul>"},{"location":"adr/0012-cassette-save-failure-behavior/#concerns","title":"Concerns","text":"<ul> <li>Saves are synchronous; transient I/O failures will fail the request (mitigation: implement a retrying or buffered CassetteStore).</li> <li>Users who want \"best-effort persistence\" must implement a custom store that swallows or defers errors (mitigation: provide a documented example store if demand emerges).</li> </ul>"},{"location":"adr/0012-cassette-save-failure-behavior/#alternatives","title":"Alternatives","text":""},{"location":"adr/0012-cassette-save-failure-behavior/#best-effort-save-log-and-continue","title":"Best-effort save (log and continue)","text":"<ul> <li>Pros: Response always delivered.</li> <li>Cons: Failures can be hidden, undermining reproducibility.</li> <li>Reason for rejection: Conflicts with the primary testing motivation.</li> </ul>"},{"location":"adr/0012-cassette-save-failure-behavior/#configurable-save-failure-policy","title":"Configurable save failure policy","text":"<ul> <li>Pros: Flexible for different use cases.</li> <li>Cons: Adds complexity and policy surface area.</li> <li>Reason for deferral: Not needed for current scope; can be revisited if demand emerges.</li> </ul>"},{"location":"adr/0012-cassette-save-failure-behavior/#future-direction","title":"Future Direction","text":"<p>Revisit if:</p> <ul> <li>Users request configurable save-failure policies (e.g., warn-and-continue).</li> <li>An async broker is introduced and persistence behavior changes.</li> <li>The project adds standardized store adapters beyond the JSON file reference.</li> </ul>"},{"location":"adr/0012-cassette-save-failure-behavior/#references","title":"References","text":"<ul> <li>ADR 0011: CassetteStore Persistence Port</li> </ul>"},{"location":"api/api_reference/","title":"API Reference","text":"<p>This page documents the public API of the interposition library.</p>"},{"location":"api/api_reference/#core-module","title":"Core Module","text":""},{"location":"api/api_reference/#interposition","title":"interposition","text":"<p>Protocol-agnostic interaction interposition with lifecycle hooks.</p> <p>Provides record, replay, and control capabilities.</p>"},{"location":"api/api_reference/#interposition.BrokerMode","title":"BrokerMode  <code>module-attribute</code>","text":"<pre><code>BrokerMode = Literal['replay', 'record', 'auto']\n</code></pre>"},{"location":"api/api_reference/#interposition.Broker","title":"Broker","text":"<p>Manages interaction replay from cassettes.</p> <p>Attributes:</p> Name Type Description <code>cassette</code> <code>Cassette</code> <p>The cassette containing recorded interactions</p> <code>mode</code> <code>BrokerMode</code> <p>The broker mode (replay, record, or auto)</p> <code>live_responder</code> <code>LiveResponder | None</code> <p>Optional callable for upstream forwarding</p> <code>cassette_store</code> <code>CassetteStore | None</code> <p>Optional store for cassette persistence</p> Source code in <code>src/interposition/services.py</code> <pre><code>class Broker:\n    \"\"\"Manages interaction replay from cassettes.\n\n    Attributes:\n        cassette: The cassette containing recorded interactions\n        mode: The broker mode (replay, record, or auto)\n        live_responder: Optional callable for upstream forwarding\n        cassette_store: Optional store for cassette persistence\n    \"\"\"\n\n    def __init__(\n        self,\n        cassette: Cassette,\n        mode: BrokerMode = \"replay\",\n        live_responder: LiveResponder | None = None,\n        cassette_store: CassetteStore | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize broker with a cassette.\n\n        Args:\n            cassette: The cassette containing recorded interactions\n            mode: The broker mode (replay, record, or auto)\n            live_responder: Optional callable for upstream forwarding\n            cassette_store: Optional store for automatic cassette persistence\n        \"\"\"\n        self._cassette = cassette\n        self._mode = mode\n        self._live_responder = live_responder\n        self._cassette_store = cassette_store\n\n    @property\n    def cassette(self) -&gt; Cassette:\n        \"\"\"Get the cassette.\"\"\"\n        return self._cassette\n\n    @property\n    def mode(self) -&gt; BrokerMode:\n        \"\"\"Get the broker mode.\"\"\"\n        return self._mode\n\n    @property\n    def live_responder(self) -&gt; LiveResponder | None:\n        \"\"\"Get the live responder.\"\"\"\n        return self._live_responder\n\n    @property\n    def cassette_store(self) -&gt; CassetteStore | None:\n        \"\"\"Get the cassette store.\"\"\"\n        return self._cassette_store\n\n    def replay(self, request: InteractionRequest) -&gt; Iterator[ResponseChunk]:\n        \"\"\"Replay recorded response for matching request.\n\n        Args:\n            request: The request to match and replay\n\n        Yields:\n            ResponseChunks in original recorded order\n\n        Raises:\n            InteractionNotFoundError: When no matching interaction exists\n                and mode is replay, or when mode is auto but no\n                live_responder is configured.\n            LiveResponderRequiredError: When mode is record but no\n                live_responder is configured.\n        \"\"\"\n        # record mode: always forward to live, ignore cassette\n        if self._mode == \"record\":\n            yield from self._forward_and_record(request)\n            return\n\n        # replay/auto mode: try cassette first\n        interaction = self.cassette.find_interaction(request.fingerprint())\n        if interaction is not None:\n            yield from interaction.response_chunks\n            return\n\n        # MISS handling\n        if self._mode == \"replay\":\n            raise InteractionNotFoundError(request)\n\n        # auto mode MISS: forward to live\n        yield from self._forward_and_record(request)\n\n    def _forward_and_record(\n        self, request: InteractionRequest\n    ) -&gt; Iterator[ResponseChunk]:\n        \"\"\"Forward request to live responder and record the interaction.\n\n        Args:\n            request: The request to forward\n\n        Yields:\n            ResponseChunks from live responder\n\n        Raises:\n            LiveResponderRequiredError: When live_responder is not configured\n                and mode is record.\n            InteractionNotFoundError: When live_responder is not configured\n                and mode is auto.\n        \"\"\"\n        if self._live_responder is None:\n            if self._mode == \"record\":\n                raise LiveResponderRequiredError(self._mode)\n            raise InteractionNotFoundError(request)\n\n        chunks = tuple(self._live_responder(request))\n        self._record_interaction(request, chunks)\n        if self._cassette_store is not None:\n            self._cassette_store.save(self._cassette)\n        yield from chunks\n\n    def _record_interaction(\n        self,\n        request: InteractionRequest,\n        response_chunks: tuple[ResponseChunk, ...],\n    ) -&gt; None:\n        \"\"\"Record a new interaction to the cassette.\n\n        Creates a new Cassette with the interaction appended.\n\n        Args:\n            request: The request that was made\n            response_chunks: The response chunks from live responder\n        \"\"\"\n        interaction = Interaction(\n            request=request,\n            fingerprint=request.fingerprint(),\n            response_chunks=response_chunks,\n        )\n        new_interactions = (*self._cassette.interactions, interaction)\n        self._cassette = Cassette(interactions=new_interactions)\n</code></pre>"},{"location":"api/api_reference/#interposition.Broker.cassette","title":"cassette  <code>property</code>","text":"<pre><code>cassette: Cassette\n</code></pre> <p>Get the cassette.</p>"},{"location":"api/api_reference/#interposition.Broker.mode","title":"mode  <code>property</code>","text":"<pre><code>mode: BrokerMode\n</code></pre> <p>Get the broker mode.</p>"},{"location":"api/api_reference/#interposition.Broker.live_responder","title":"live_responder  <code>property</code>","text":"<pre><code>live_responder: LiveResponder | None\n</code></pre> <p>Get the live responder.</p>"},{"location":"api/api_reference/#interposition.Broker.cassette_store","title":"cassette_store  <code>property</code>","text":"<pre><code>cassette_store: CassetteStore | None\n</code></pre> <p>Get the cassette store.</p>"},{"location":"api/api_reference/#interposition.Broker.__init__","title":"__init__","text":"<pre><code>__init__(\n    cassette: Cassette,\n    mode: BrokerMode = \"replay\",\n    live_responder: LiveResponder | None = None,\n    cassette_store: CassetteStore | None = None,\n) -&gt; None\n</code></pre> <p>Initialize broker with a cassette.</p> <p>Parameters:</p> Name Type Description Default <code>cassette</code> <code>Cassette</code> <p>The cassette containing recorded interactions</p> required <code>mode</code> <code>BrokerMode</code> <p>The broker mode (replay, record, or auto)</p> <code>'replay'</code> <code>live_responder</code> <code>LiveResponder | None</code> <p>Optional callable for upstream forwarding</p> <code>None</code> <code>cassette_store</code> <code>CassetteStore | None</code> <p>Optional store for automatic cassette persistence</p> <code>None</code> Source code in <code>src/interposition/services.py</code> <pre><code>def __init__(\n    self,\n    cassette: Cassette,\n    mode: BrokerMode = \"replay\",\n    live_responder: LiveResponder | None = None,\n    cassette_store: CassetteStore | None = None,\n) -&gt; None:\n    \"\"\"Initialize broker with a cassette.\n\n    Args:\n        cassette: The cassette containing recorded interactions\n        mode: The broker mode (replay, record, or auto)\n        live_responder: Optional callable for upstream forwarding\n        cassette_store: Optional store for automatic cassette persistence\n    \"\"\"\n    self._cassette = cassette\n    self._mode = mode\n    self._live_responder = live_responder\n    self._cassette_store = cassette_store\n</code></pre>"},{"location":"api/api_reference/#interposition.Broker.replay","title":"replay","text":"<pre><code>replay(\n    request: InteractionRequest,\n) -&gt; Iterator[ResponseChunk]\n</code></pre> <p>Replay recorded response for matching request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>InteractionRequest</code> <p>The request to match and replay</p> required <p>Yields:</p> Type Description <code>ResponseChunk</code> <p>ResponseChunks in original recorded order</p> <p>Raises:</p> Type Description <code>InteractionNotFoundError</code> <p>When no matching interaction exists and mode is replay, or when mode is auto but no live_responder is configured.</p> <code>LiveResponderRequiredError</code> <p>When mode is record but no live_responder is configured.</p> Source code in <code>src/interposition/services.py</code> <pre><code>def replay(self, request: InteractionRequest) -&gt; Iterator[ResponseChunk]:\n    \"\"\"Replay recorded response for matching request.\n\n    Args:\n        request: The request to match and replay\n\n    Yields:\n        ResponseChunks in original recorded order\n\n    Raises:\n        InteractionNotFoundError: When no matching interaction exists\n            and mode is replay, or when mode is auto but no\n            live_responder is configured.\n        LiveResponderRequiredError: When mode is record but no\n            live_responder is configured.\n    \"\"\"\n    # record mode: always forward to live, ignore cassette\n    if self._mode == \"record\":\n        yield from self._forward_and_record(request)\n        return\n\n    # replay/auto mode: try cassette first\n    interaction = self.cassette.find_interaction(request.fingerprint())\n    if interaction is not None:\n        yield from interaction.response_chunks\n        return\n\n    # MISS handling\n    if self._mode == \"replay\":\n        raise InteractionNotFoundError(request)\n\n    # auto mode MISS: forward to live\n    yield from self._forward_and_record(request)\n</code></pre>"},{"location":"api/api_reference/#interposition.Cassette","title":"Cassette","text":"<p>               Bases: <code>BaseModel</code></p> <p>In-memory collection of recorded interactions.</p> <p>Attributes:</p> Name Type Description <code>interactions</code> <code>tuple[Interaction, ...]</code> <p>Ordered sequence of interactions</p> Source code in <code>src/interposition/models.py</code> <pre><code>class Cassette(BaseModel):\n    \"\"\"In-memory collection of recorded interactions.\n\n    Attributes:\n        interactions: Ordered sequence of interactions\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    interactions: tuple[Interaction, ...]\n    _index: dict[RequestFingerprint, int] = PrivateAttr(default_factory=dict)\n\n    @model_validator(mode=\"after\")\n    def build_index(self) -&gt; Self:\n        \"\"\"Build fingerprint index for efficient lookup.\"\"\"\n        index: dict[RequestFingerprint, int] = {}\n        for i, interaction in enumerate(self.interactions):\n            # Only store first occurrence of each fingerprint\n            if interaction.fingerprint not in index:\n                index[interaction.fingerprint] = i\n        # Use object.__setattr__ to modify frozen model\n        object.__setattr__(self, \"_index\", index)\n        return self\n\n    def find_interaction(self, fingerprint: RequestFingerprint) -&gt; Interaction | None:\n        \"\"\"Find first interaction matching fingerprint.\n\n        Args:\n            fingerprint: Request fingerprint to search for\n\n        Returns:\n            Matching Interaction or None if not found\n        \"\"\"\n        position = self._index.get(fingerprint)\n        if position is None:\n            return None\n        return self.interactions[position]\n</code></pre>"},{"location":"api/api_reference/#interposition.Cassette.build_index","title":"build_index","text":"<pre><code>build_index() -&gt; Self\n</code></pre> <p>Build fingerprint index for efficient lookup.</p> Source code in <code>src/interposition/models.py</code> <pre><code>@model_validator(mode=\"after\")\ndef build_index(self) -&gt; Self:\n    \"\"\"Build fingerprint index for efficient lookup.\"\"\"\n    index: dict[RequestFingerprint, int] = {}\n    for i, interaction in enumerate(self.interactions):\n        # Only store first occurrence of each fingerprint\n        if interaction.fingerprint not in index:\n            index[interaction.fingerprint] = i\n    # Use object.__setattr__ to modify frozen model\n    object.__setattr__(self, \"_index\", index)\n    return self\n</code></pre>"},{"location":"api/api_reference/#interposition.Cassette.find_interaction","title":"find_interaction","text":"<pre><code>find_interaction(\n    fingerprint: RequestFingerprint,\n) -&gt; Interaction | None\n</code></pre> <p>Find first interaction matching fingerprint.</p> <p>Parameters:</p> Name Type Description Default <code>fingerprint</code> <code>RequestFingerprint</code> <p>Request fingerprint to search for</p> required <p>Returns:</p> Type Description <code>Interaction | None</code> <p>Matching Interaction or None if not found</p> Source code in <code>src/interposition/models.py</code> <pre><code>def find_interaction(self, fingerprint: RequestFingerprint) -&gt; Interaction | None:\n    \"\"\"Find first interaction matching fingerprint.\n\n    Args:\n        fingerprint: Request fingerprint to search for\n\n    Returns:\n        Matching Interaction or None if not found\n    \"\"\"\n    position = self._index.get(fingerprint)\n    if position is None:\n        return None\n    return self.interactions[position]\n</code></pre>"},{"location":"api/api_reference/#interposition.CassetteStore","title":"CassetteStore","text":"<p>               Bases: <code>Protocol</code></p> <p>Port for cassette persistence operations.</p> <p>Implementations handle loading and saving cassettes to storage. The Broker calls save() automatically after recording new interactions.</p> Source code in <code>src/interposition/services.py</code> <pre><code>class CassetteStore(Protocol):\n    \"\"\"Port for cassette persistence operations.\n\n    Implementations handle loading and saving cassettes to storage.\n    The Broker calls save() automatically after recording new interactions.\n    \"\"\"\n\n    def load(self) -&gt; Cassette:\n        \"\"\"Load cassette from storage.\n\n        Returns:\n            The loaded Cassette instance.\n        \"\"\"\n        ...\n\n    def save(self, cassette: Cassette) -&gt; None:\n        \"\"\"Save cassette to storage.\n\n        Args:\n            cassette: The cassette to persist.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/api_reference/#interposition.CassetteStore.load","title":"load","text":"<pre><code>load() -&gt; Cassette\n</code></pre> <p>Load cassette from storage.</p> <p>Returns:</p> Type Description <code>Cassette</code> <p>The loaded Cassette instance.</p> Source code in <code>src/interposition/services.py</code> <pre><code>def load(self) -&gt; Cassette:\n    \"\"\"Load cassette from storage.\n\n    Returns:\n        The loaded Cassette instance.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/api_reference/#interposition.CassetteStore.save","title":"save","text":"<pre><code>save(cassette: Cassette) -&gt; None\n</code></pre> <p>Save cassette to storage.</p> <p>Parameters:</p> Name Type Description Default <code>cassette</code> <code>Cassette</code> <p>The cassette to persist.</p> required Source code in <code>src/interposition/services.py</code> <pre><code>def save(self, cassette: Cassette) -&gt; None:\n    \"\"\"Save cassette to storage.\n\n    Args:\n        cassette: The cassette to persist.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/api_reference/#interposition.Interaction","title":"Interaction","text":"<p>               Bases: <code>BaseModel</code></p> <p>Complete request-response pair for replay.</p> <p>Attributes:</p> Name Type Description <code>request</code> <code>InteractionRequest</code> <p>The original InteractionRequest</p> <code>fingerprint</code> <code>RequestFingerprint</code> <p>Precomputed request fingerprint for matching</p> <code>response_chunks</code> <code>tuple[ResponseChunk, ...]</code> <p>Ordered sequence of response chunks</p> <code>metadata</code> <code>tuple[tuple[str, str], ...]</code> <p>Optional interaction metadata as (key, value) pairs. Examples: recording timestamp, session ID, test scenario name. Useful for debugging and tracing recorded interactions. Default is empty tuple.</p> Source code in <code>src/interposition/models.py</code> <pre><code>class Interaction(BaseModel):\n    \"\"\"Complete request-response pair for replay.\n\n    Attributes:\n        request: The original InteractionRequest\n        fingerprint: Precomputed request fingerprint for matching\n        response_chunks: Ordered sequence of response chunks\n        metadata: Optional interaction metadata as (key, value) pairs.\n            Examples: recording timestamp, session ID, test scenario name.\n            Useful for debugging and tracing recorded interactions.\n            Default is empty tuple.\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    request: InteractionRequest\n    fingerprint: RequestFingerprint\n    response_chunks: tuple[ResponseChunk, ...]\n    metadata: tuple[tuple[str, str], ...] = ()\n\n    @model_validator(mode=\"after\")\n    def validate_interaction(self) -&gt; Self:\n        \"\"\"Validate interaction integrity.\n\n        Raises:\n            InteractionValidationError: If fingerprint doesn't match request\n                or chunks aren't sequential\n        \"\"\"\n        # Verify fingerprint matches request\n        expected_fingerprint = self.request.fingerprint()\n        if self.fingerprint != expected_fingerprint:\n            msg = (\n                f\"Fingerprint does not match request: \"\n                f\"expected {expected_fingerprint.value}, got {self.fingerprint.value}\"\n            )\n            raise InteractionValidationError(msg)\n\n        # Verify response chunks are sequentially ordered\n        if not self.response_chunks:\n            msg = \"Response chunks cannot be empty\"\n            raise InteractionValidationError(msg)\n\n        if self.response_chunks[0].sequence != 0:\n            msg = \"Response chunks must start at sequence 0\"\n            raise InteractionValidationError(msg)\n\n        for i, chunk in enumerate(self.response_chunks):\n            if chunk.sequence != i:\n                msg = \"Response chunks must be sequential with no gaps\"\n                raise InteractionValidationError(msg)\n\n        return self\n</code></pre>"},{"location":"api/api_reference/#interposition.Interaction.validate_interaction","title":"validate_interaction","text":"<pre><code>validate_interaction() -&gt; Self\n</code></pre> <p>Validate interaction integrity.</p> <p>Raises:</p> Type Description <code>InteractionValidationError</code> <p>If fingerprint doesn't match request or chunks aren't sequential</p> Source code in <code>src/interposition/models.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_interaction(self) -&gt; Self:\n    \"\"\"Validate interaction integrity.\n\n    Raises:\n        InteractionValidationError: If fingerprint doesn't match request\n            or chunks aren't sequential\n    \"\"\"\n    # Verify fingerprint matches request\n    expected_fingerprint = self.request.fingerprint()\n    if self.fingerprint != expected_fingerprint:\n        msg = (\n            f\"Fingerprint does not match request: \"\n            f\"expected {expected_fingerprint.value}, got {self.fingerprint.value}\"\n        )\n        raise InteractionValidationError(msg)\n\n    # Verify response chunks are sequentially ordered\n    if not self.response_chunks:\n        msg = \"Response chunks cannot be empty\"\n        raise InteractionValidationError(msg)\n\n    if self.response_chunks[0].sequence != 0:\n        msg = \"Response chunks must start at sequence 0\"\n        raise InteractionValidationError(msg)\n\n    for i, chunk in enumerate(self.response_chunks):\n        if chunk.sequence != i:\n            msg = \"Response chunks must be sequential with no gaps\"\n            raise InteractionValidationError(msg)\n\n    return self\n</code></pre>"},{"location":"api/api_reference/#interposition.InteractionRequest","title":"InteractionRequest","text":"<p>               Bases: <code>BaseModel</code></p> <p>Structured representation of a protocol-agnostic request.</p> <p>Attributes:</p> Name Type Description <code>protocol</code> <code>str</code> <p>Protocol identifier (e.g., \"grpc\", \"graphql\", \"mqtt\")</p> <code>action</code> <code>str</code> <p>Action/method name (e.g., \"ListUsers\", \"query\", \"publish\")</p> <code>target</code> <code>str</code> <p>Target resource (e.g., \"users.UserService\", \"topic/sensors\")</p> <code>headers</code> <code>tuple[tuple[str, str], ...]</code> <p>Request headers as immutable sequence of key-value pairs</p> <code>body</code> <code>bytes</code> <p>Request body content as bytes</p> Source code in <code>src/interposition/models.py</code> <pre><code>class InteractionRequest(BaseModel):\n    \"\"\"Structured representation of a protocol-agnostic request.\n\n    Attributes:\n        protocol: Protocol identifier (e.g., \"grpc\", \"graphql\", \"mqtt\")\n        action: Action/method name (e.g., \"ListUsers\", \"query\", \"publish\")\n        target: Target resource (e.g., \"users.UserService\", \"topic/sensors\")\n        headers: Request headers as immutable sequence of key-value pairs\n        body: Request body content as bytes\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    protocol: str\n    action: str\n    target: str\n    headers: tuple[tuple[str, str], ...]\n    body: bytes\n\n    def fingerprint(self) -&gt; RequestFingerprint:\n        \"\"\"Generate stable fingerprint for efficient matching.\n\n        Returns:\n            RequestFingerprint derived from all request fields.\n        \"\"\"\n        return RequestFingerprint.from_request(self)\n</code></pre>"},{"location":"api/api_reference/#interposition.InteractionRequest.fingerprint","title":"fingerprint","text":"<pre><code>fingerprint() -&gt; RequestFingerprint\n</code></pre> <p>Generate stable fingerprint for efficient matching.</p> <p>Returns:</p> Type Description <code>RequestFingerprint</code> <p>RequestFingerprint derived from all request fields.</p> Source code in <code>src/interposition/models.py</code> <pre><code>def fingerprint(self) -&gt; RequestFingerprint:\n    \"\"\"Generate stable fingerprint for efficient matching.\n\n    Returns:\n        RequestFingerprint derived from all request fields.\n    \"\"\"\n    return RequestFingerprint.from_request(self)\n</code></pre>"},{"location":"api/api_reference/#interposition.JsonFileCassetteStore","title":"JsonFileCassetteStore","text":"<p>File-based cassette store using JSON format.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Path</code> <p>Path to the JSON file for cassette storage.</p> Source code in <code>src/interposition/stores.py</code> <pre><code>class JsonFileCassetteStore:\n    \"\"\"File-based cassette store using JSON format.\n\n    Attributes:\n        path: Path to the JSON file for cassette storage.\n    \"\"\"\n\n    def __init__(self, path: Path) -&gt; None:\n        \"\"\"Initialize store with file path.\n\n        Args:\n            path: Path to the JSON file (will be created if doesn't exist).\n        \"\"\"\n        self._path = path\n\n    @property\n    def path(self) -&gt; Path:\n        \"\"\"Get the file path.\"\"\"\n        return self._path\n\n    def load(self) -&gt; Cassette:\n        \"\"\"Load cassette from JSON file.\n\n        Returns:\n            Cassette instance loaded from file.\n\n        Raises:\n            FileNotFoundError: If file doesn't exist.\n            pydantic.ValidationError: If JSON is invalid.\n        \"\"\"\n        json_str = self._path.read_text(encoding=\"utf-8\")\n        return Cassette.model_validate_json(json_str)\n\n    def save(self, cassette: Cassette) -&gt; None:\n        \"\"\"Save cassette to JSON file.\n\n        Creates parent directories if they don't exist.\n\n        Args:\n            cassette: The cassette to persist.\n\n        Raises:\n            CassetteSaveError: If file write fails.\n        \"\"\"\n        try:\n            self._path.parent.mkdir(parents=True, exist_ok=True)\n            json_str = cassette.model_dump_json(indent=2)\n            self._path.write_text(json_str, encoding=\"utf-8\")\n        except OSError as e:\n            raise CassetteSaveError(self._path, e) from e\n</code></pre>"},{"location":"api/api_reference/#interposition.JsonFileCassetteStore.path","title":"path  <code>property</code>","text":"<pre><code>path: Path\n</code></pre> <p>Get the file path.</p>"},{"location":"api/api_reference/#interposition.JsonFileCassetteStore.__init__","title":"__init__","text":"<pre><code>__init__(path: Path) -&gt; None\n</code></pre> <p>Initialize store with file path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the JSON file (will be created if doesn't exist).</p> required Source code in <code>src/interposition/stores.py</code> <pre><code>def __init__(self, path: Path) -&gt; None:\n    \"\"\"Initialize store with file path.\n\n    Args:\n        path: Path to the JSON file (will be created if doesn't exist).\n    \"\"\"\n    self._path = path\n</code></pre>"},{"location":"api/api_reference/#interposition.JsonFileCassetteStore.load","title":"load","text":"<pre><code>load() -&gt; Cassette\n</code></pre> <p>Load cassette from JSON file.</p> <p>Returns:</p> Type Description <code>Cassette</code> <p>Cassette instance loaded from file.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist.</p> <code>ValidationError</code> <p>If JSON is invalid.</p> Source code in <code>src/interposition/stores.py</code> <pre><code>def load(self) -&gt; Cassette:\n    \"\"\"Load cassette from JSON file.\n\n    Returns:\n        Cassette instance loaded from file.\n\n    Raises:\n        FileNotFoundError: If file doesn't exist.\n        pydantic.ValidationError: If JSON is invalid.\n    \"\"\"\n    json_str = self._path.read_text(encoding=\"utf-8\")\n    return Cassette.model_validate_json(json_str)\n</code></pre>"},{"location":"api/api_reference/#interposition.JsonFileCassetteStore.save","title":"save","text":"<pre><code>save(cassette: Cassette) -&gt; None\n</code></pre> <p>Save cassette to JSON file.</p> <p>Creates parent directories if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>cassette</code> <code>Cassette</code> <p>The cassette to persist.</p> required <p>Raises:</p> Type Description <code>CassetteSaveError</code> <p>If file write fails.</p> Source code in <code>src/interposition/stores.py</code> <pre><code>def save(self, cassette: Cassette) -&gt; None:\n    \"\"\"Save cassette to JSON file.\n\n    Creates parent directories if they don't exist.\n\n    Args:\n        cassette: The cassette to persist.\n\n    Raises:\n        CassetteSaveError: If file write fails.\n    \"\"\"\n    try:\n        self._path.parent.mkdir(parents=True, exist_ok=True)\n        json_str = cassette.model_dump_json(indent=2)\n        self._path.write_text(json_str, encoding=\"utf-8\")\n    except OSError as e:\n        raise CassetteSaveError(self._path, e) from e\n</code></pre>"},{"location":"api/api_reference/#interposition.ResponseChunk","title":"ResponseChunk","text":"<p>               Bases: <code>BaseModel</code></p> <p>Discrete piece of response data.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>bytes</code> <p>Chunk payload as bytes</p> <code>sequence</code> <code>int</code> <p>Zero-based chunk position in response stream</p> <code>metadata</code> <code>tuple[tuple[str, str], ...]</code> <p>Optional chunk metadata as (key, value) string pairs. Examples: timing info, encoding, content-type for this chunk. Default is empty tuple.</p> Source code in <code>src/interposition/models.py</code> <pre><code>class ResponseChunk(BaseModel):\n    \"\"\"Discrete piece of response data.\n\n    Attributes:\n        data: Chunk payload as bytes\n        sequence: Zero-based chunk position in response stream\n        metadata: Optional chunk metadata as (key, value) string pairs.\n            Examples: timing info, encoding, content-type for this chunk.\n            Default is empty tuple.\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    data: bytes\n    sequence: int\n    metadata: tuple[tuple[str, str], ...] = ()\n</code></pre>"},{"location":"api/api_reference/#interposition.RequestFingerprint","title":"RequestFingerprint","text":"<p>               Bases: <code>BaseModel</code></p> <p>Stable unique identifier for request matching.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>str</code> <p>SHA-256 hash of canonicalized request fields</p> Source code in <code>src/interposition/models.py</code> <pre><code>class RequestFingerprint(BaseModel):\n    \"\"\"Stable unique identifier for request matching.\n\n    Attributes:\n        value: SHA-256 hash of canonicalized request fields\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    value: str\n\n    @field_validator(\"value\")\n    @classmethod\n    def validate_sha256_hex(cls, v: str) -&gt; str:\n        \"\"\"Validate that value is a valid SHA-256 hex string.\n\n        Args:\n            v: The fingerprint value to validate\n\n        Returns:\n            The validated value\n\n        Raises:\n            ValueError: If value is not exactly 64 hex characters\n        \"\"\"\n        if len(v) != SHA256_HEX_LENGTH:\n            msg = f\"SHA-256 hex must be exactly {SHA256_HEX_LENGTH} characters\"\n            raise ValueError(msg)\n        if not all(c in \"0123456789abcdef\" for c in v):\n            msg = \"Invalid hex characters in fingerprint\"\n            raise ValueError(msg)\n        return v\n\n    @classmethod\n    def from_request(cls, request: InteractionRequest) -&gt; Self:\n        \"\"\"Create fingerprint from InteractionRequest.\n\n        Args:\n            request: The request to fingerprint\n\n        Returns:\n            RequestFingerprint with SHA-256 hash value\n        \"\"\"\n        # Canonical order: protocol, action, target, headers, body\n        # Preserve header ordering to avoid normalization.\n        canonical_data = [\n            request.protocol,\n            request.action,\n            request.target,\n            request.headers,\n            request.body.hex(),\n        ]\n        canonical = json.dumps(\n            canonical_data,\n            separators=_CANONICAL_JSON_SEPARATORS,\n            sort_keys=_CANONICAL_JSON_SORT_KEYS,\n        )\n        hash_value = hashlib.sha256(canonical.encode(\"utf-8\")).hexdigest()\n        return cls(value=hash_value)\n</code></pre>"},{"location":"api/api_reference/#interposition.RequestFingerprint.validate_sha256_hex","title":"validate_sha256_hex  <code>classmethod</code>","text":"<pre><code>validate_sha256_hex(v: str) -&gt; str\n</code></pre> <p>Validate that value is a valid SHA-256 hex string.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>The fingerprint value to validate</p> required <p>Returns:</p> Type Description <code>str</code> <p>The validated value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If value is not exactly 64 hex characters</p> Source code in <code>src/interposition/models.py</code> <pre><code>@field_validator(\"value\")\n@classmethod\ndef validate_sha256_hex(cls, v: str) -&gt; str:\n    \"\"\"Validate that value is a valid SHA-256 hex string.\n\n    Args:\n        v: The fingerprint value to validate\n\n    Returns:\n        The validated value\n\n    Raises:\n        ValueError: If value is not exactly 64 hex characters\n    \"\"\"\n    if len(v) != SHA256_HEX_LENGTH:\n        msg = f\"SHA-256 hex must be exactly {SHA256_HEX_LENGTH} characters\"\n        raise ValueError(msg)\n    if not all(c in \"0123456789abcdef\" for c in v):\n        msg = \"Invalid hex characters in fingerprint\"\n        raise ValueError(msg)\n    return v\n</code></pre>"},{"location":"api/api_reference/#interposition.RequestFingerprint.from_request","title":"from_request  <code>classmethod</code>","text":"<pre><code>from_request(request: InteractionRequest) -&gt; Self\n</code></pre> <p>Create fingerprint from InteractionRequest.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>InteractionRequest</code> <p>The request to fingerprint</p> required <p>Returns:</p> Type Description <code>Self</code> <p>RequestFingerprint with SHA-256 hash value</p> Source code in <code>src/interposition/models.py</code> <pre><code>@classmethod\ndef from_request(cls, request: InteractionRequest) -&gt; Self:\n    \"\"\"Create fingerprint from InteractionRequest.\n\n    Args:\n        request: The request to fingerprint\n\n    Returns:\n        RequestFingerprint with SHA-256 hash value\n    \"\"\"\n    # Canonical order: protocol, action, target, headers, body\n    # Preserve header ordering to avoid normalization.\n    canonical_data = [\n        request.protocol,\n        request.action,\n        request.target,\n        request.headers,\n        request.body.hex(),\n    ]\n    canonical = json.dumps(\n        canonical_data,\n        separators=_CANONICAL_JSON_SEPARATORS,\n        sort_keys=_CANONICAL_JSON_SORT_KEYS,\n    )\n    hash_value = hashlib.sha256(canonical.encode(\"utf-8\")).hexdigest()\n    return cls(value=hash_value)\n</code></pre>"},{"location":"api/api_reference/#interposition.CassetteSaveError","title":"CassetteSaveError","text":"<p>               Bases: <code>InterpositionError</code></p> <p>Raised when cassette persistence fails.</p> Source code in <code>src/interposition/errors.py</code> <pre><code>class CassetteSaveError(InterpositionError):\n    \"\"\"Raised when cassette persistence fails.\"\"\"\n\n    def __init__(self, path: Path, cause: Exception) -&gt; None:\n        \"\"\"Initialize with the path and underlying cause.\n\n        Args:\n            path: The file path where save failed\n            cause: The underlying exception that caused the failure\n        \"\"\"\n        super().__init__(f\"Failed to save cassette to {path}: {cause}\")\n        self.path: Path = path\n        self.__cause__ = cause\n</code></pre>"},{"location":"api/api_reference/#interposition.CassetteSaveError.__init__","title":"__init__","text":"<pre><code>__init__(path: Path, cause: Exception) -&gt; None\n</code></pre> <p>Initialize with the path and underlying cause.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The file path where save failed</p> required <code>cause</code> <code>Exception</code> <p>The underlying exception that caused the failure</p> required Source code in <code>src/interposition/errors.py</code> <pre><code>def __init__(self, path: Path, cause: Exception) -&gt; None:\n    \"\"\"Initialize with the path and underlying cause.\n\n    Args:\n        path: The file path where save failed\n        cause: The underlying exception that caused the failure\n    \"\"\"\n    super().__init__(f\"Failed to save cassette to {path}: {cause}\")\n    self.path: Path = path\n    self.__cause__ = cause\n</code></pre>"},{"location":"api/api_reference/#interposition.InteractionNotFoundError","title":"InteractionNotFoundError","text":"<p>               Bases: <code>InterpositionError</code></p> <p>Raised when no matching interaction is found in cassette.</p> Source code in <code>src/interposition/errors.py</code> <pre><code>class InteractionNotFoundError(InterpositionError):\n    \"\"\"Raised when no matching interaction is found in cassette.\"\"\"\n\n    def __init__(self, request: InteractionRequest) -&gt; None:\n        \"\"\"Initialize with request that failed to match.\n\n        Args:\n            request: The unmatched request\n        \"\"\"\n        super().__init__(\n            f\"No matching interaction for {request.protocol}:\"\n            f\"{request.action}:{request.target}\"\n        )\n        self.request: InteractionRequest = request\n</code></pre>"},{"location":"api/api_reference/#interposition.InteractionNotFoundError.__init__","title":"__init__","text":"<pre><code>__init__(request: InteractionRequest) -&gt; None\n</code></pre> <p>Initialize with request that failed to match.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>InteractionRequest</code> <p>The unmatched request</p> required Source code in <code>src/interposition/errors.py</code> <pre><code>def __init__(self, request: InteractionRequest) -&gt; None:\n    \"\"\"Initialize with request that failed to match.\n\n    Args:\n        request: The unmatched request\n    \"\"\"\n    super().__init__(\n        f\"No matching interaction for {request.protocol}:\"\n        f\"{request.action}:{request.target}\"\n    )\n    self.request: InteractionRequest = request\n</code></pre>"},{"location":"api/api_reference/#interposition.InteractionValidationError","title":"InteractionValidationError","text":"<p>               Bases: <code>InterpositionError</code>, <code>ValueError</code></p> <p>Raised when interaction validation fails.</p> Source code in <code>src/interposition/models.py</code> <pre><code>class InteractionValidationError(InterpositionError, ValueError):\n    \"\"\"Raised when interaction validation fails.\"\"\"\n</code></pre>"},{"location":"api/api_reference/#interposition.InterpositionError","title":"InterpositionError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all interposition exceptions.</p> Source code in <code>src/interposition/errors.py</code> <pre><code>class InterpositionError(Exception):\n    \"\"\"Base class for all interposition exceptions.\"\"\"\n</code></pre>"},{"location":"api/api_reference/#interposition.LiveResponderRequiredError","title":"LiveResponderRequiredError","text":"<p>               Bases: <code>InterpositionError</code></p> <p>Raised when live_responder is required but not configured.</p> Source code in <code>src/interposition/errors.py</code> <pre><code>class LiveResponderRequiredError(InterpositionError):\n    \"\"\"Raised when live_responder is required but not configured.\"\"\"\n\n    def __init__(self, mode: str) -&gt; None:\n        \"\"\"Initialize with the mode that requires live_responder.\n\n        Args:\n            mode: The broker mode that requires live_responder\n        \"\"\"\n        super().__init__(f\"live_responder is required for {mode} mode\")\n        self.mode: str = mode\n</code></pre>"},{"location":"api/api_reference/#interposition.LiveResponderRequiredError.__init__","title":"__init__","text":"<pre><code>__init__(mode: str) -&gt; None\n</code></pre> <p>Initialize with the mode that requires live_responder.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>The broker mode that requires live_responder</p> required Source code in <code>src/interposition/errors.py</code> <pre><code>def __init__(self, mode: str) -&gt; None:\n    \"\"\"Initialize with the mode that requires live_responder.\n\n    Args:\n        mode: The broker mode that requires live_responder\n    \"\"\"\n    super().__init__(f\"live_responder is required for {mode} mode\")\n    self.mode: str = mode\n</code></pre>"},{"location":"api/api_reference/#services","title":"Services","text":""},{"location":"api/api_reference/#interposition.services.Broker","title":"interposition.services.Broker","text":"<p>Manages interaction replay from cassettes.</p> <p>Attributes:</p> Name Type Description <code>cassette</code> <code>Cassette</code> <p>The cassette containing recorded interactions</p> <code>mode</code> <code>BrokerMode</code> <p>The broker mode (replay, record, or auto)</p> <code>live_responder</code> <code>LiveResponder | None</code> <p>Optional callable for upstream forwarding</p> <code>cassette_store</code> <code>CassetteStore | None</code> <p>Optional store for cassette persistence</p> Source code in <code>src/interposition/services.py</code> <pre><code>class Broker:\n    \"\"\"Manages interaction replay from cassettes.\n\n    Attributes:\n        cassette: The cassette containing recorded interactions\n        mode: The broker mode (replay, record, or auto)\n        live_responder: Optional callable for upstream forwarding\n        cassette_store: Optional store for cassette persistence\n    \"\"\"\n\n    def __init__(\n        self,\n        cassette: Cassette,\n        mode: BrokerMode = \"replay\",\n        live_responder: LiveResponder | None = None,\n        cassette_store: CassetteStore | None = None,\n    ) -&gt; None:\n        \"\"\"Initialize broker with a cassette.\n\n        Args:\n            cassette: The cassette containing recorded interactions\n            mode: The broker mode (replay, record, or auto)\n            live_responder: Optional callable for upstream forwarding\n            cassette_store: Optional store for automatic cassette persistence\n        \"\"\"\n        self._cassette = cassette\n        self._mode = mode\n        self._live_responder = live_responder\n        self._cassette_store = cassette_store\n\n    @property\n    def cassette(self) -&gt; Cassette:\n        \"\"\"Get the cassette.\"\"\"\n        return self._cassette\n\n    @property\n    def mode(self) -&gt; BrokerMode:\n        \"\"\"Get the broker mode.\"\"\"\n        return self._mode\n\n    @property\n    def live_responder(self) -&gt; LiveResponder | None:\n        \"\"\"Get the live responder.\"\"\"\n        return self._live_responder\n\n    @property\n    def cassette_store(self) -&gt; CassetteStore | None:\n        \"\"\"Get the cassette store.\"\"\"\n        return self._cassette_store\n\n    def replay(self, request: InteractionRequest) -&gt; Iterator[ResponseChunk]:\n        \"\"\"Replay recorded response for matching request.\n\n        Args:\n            request: The request to match and replay\n\n        Yields:\n            ResponseChunks in original recorded order\n\n        Raises:\n            InteractionNotFoundError: When no matching interaction exists\n                and mode is replay, or when mode is auto but no\n                live_responder is configured.\n            LiveResponderRequiredError: When mode is record but no\n                live_responder is configured.\n        \"\"\"\n        # record mode: always forward to live, ignore cassette\n        if self._mode == \"record\":\n            yield from self._forward_and_record(request)\n            return\n\n        # replay/auto mode: try cassette first\n        interaction = self.cassette.find_interaction(request.fingerprint())\n        if interaction is not None:\n            yield from interaction.response_chunks\n            return\n\n        # MISS handling\n        if self._mode == \"replay\":\n            raise InteractionNotFoundError(request)\n\n        # auto mode MISS: forward to live\n        yield from self._forward_and_record(request)\n\n    def _forward_and_record(\n        self, request: InteractionRequest\n    ) -&gt; Iterator[ResponseChunk]:\n        \"\"\"Forward request to live responder and record the interaction.\n\n        Args:\n            request: The request to forward\n\n        Yields:\n            ResponseChunks from live responder\n\n        Raises:\n            LiveResponderRequiredError: When live_responder is not configured\n                and mode is record.\n            InteractionNotFoundError: When live_responder is not configured\n                and mode is auto.\n        \"\"\"\n        if self._live_responder is None:\n            if self._mode == \"record\":\n                raise LiveResponderRequiredError(self._mode)\n            raise InteractionNotFoundError(request)\n\n        chunks = tuple(self._live_responder(request))\n        self._record_interaction(request, chunks)\n        if self._cassette_store is not None:\n            self._cassette_store.save(self._cassette)\n        yield from chunks\n\n    def _record_interaction(\n        self,\n        request: InteractionRequest,\n        response_chunks: tuple[ResponseChunk, ...],\n    ) -&gt; None:\n        \"\"\"Record a new interaction to the cassette.\n\n        Creates a new Cassette with the interaction appended.\n\n        Args:\n            request: The request that was made\n            response_chunks: The response chunks from live responder\n        \"\"\"\n        interaction = Interaction(\n            request=request,\n            fingerprint=request.fingerprint(),\n            response_chunks=response_chunks,\n        )\n        new_interactions = (*self._cassette.interactions, interaction)\n        self._cassette = Cassette(interactions=new_interactions)\n</code></pre>"},{"location":"api/api_reference/#interposition.services.Broker.cassette","title":"cassette  <code>property</code>","text":"<pre><code>cassette: Cassette\n</code></pre> <p>Get the cassette.</p>"},{"location":"api/api_reference/#interposition.services.Broker.mode","title":"mode  <code>property</code>","text":"<pre><code>mode: BrokerMode\n</code></pre> <p>Get the broker mode.</p>"},{"location":"api/api_reference/#interposition.services.Broker.live_responder","title":"live_responder  <code>property</code>","text":"<pre><code>live_responder: LiveResponder | None\n</code></pre> <p>Get the live responder.</p>"},{"location":"api/api_reference/#interposition.services.Broker.cassette_store","title":"cassette_store  <code>property</code>","text":"<pre><code>cassette_store: CassetteStore | None\n</code></pre> <p>Get the cassette store.</p>"},{"location":"api/api_reference/#interposition.services.Broker.__init__","title":"__init__","text":"<pre><code>__init__(\n    cassette: Cassette,\n    mode: BrokerMode = \"replay\",\n    live_responder: LiveResponder | None = None,\n    cassette_store: CassetteStore | None = None,\n) -&gt; None\n</code></pre> <p>Initialize broker with a cassette.</p> <p>Parameters:</p> Name Type Description Default <code>cassette</code> <code>Cassette</code> <p>The cassette containing recorded interactions</p> required <code>mode</code> <code>BrokerMode</code> <p>The broker mode (replay, record, or auto)</p> <code>'replay'</code> <code>live_responder</code> <code>LiveResponder | None</code> <p>Optional callable for upstream forwarding</p> <code>None</code> <code>cassette_store</code> <code>CassetteStore | None</code> <p>Optional store for automatic cassette persistence</p> <code>None</code> Source code in <code>src/interposition/services.py</code> <pre><code>def __init__(\n    self,\n    cassette: Cassette,\n    mode: BrokerMode = \"replay\",\n    live_responder: LiveResponder | None = None,\n    cassette_store: CassetteStore | None = None,\n) -&gt; None:\n    \"\"\"Initialize broker with a cassette.\n\n    Args:\n        cassette: The cassette containing recorded interactions\n        mode: The broker mode (replay, record, or auto)\n        live_responder: Optional callable for upstream forwarding\n        cassette_store: Optional store for automatic cassette persistence\n    \"\"\"\n    self._cassette = cassette\n    self._mode = mode\n    self._live_responder = live_responder\n    self._cassette_store = cassette_store\n</code></pre>"},{"location":"api/api_reference/#interposition.services.Broker.replay","title":"replay","text":"<pre><code>replay(\n    request: InteractionRequest,\n) -&gt; Iterator[ResponseChunk]\n</code></pre> <p>Replay recorded response for matching request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>InteractionRequest</code> <p>The request to match and replay</p> required <p>Yields:</p> Type Description <code>ResponseChunk</code> <p>ResponseChunks in original recorded order</p> <p>Raises:</p> Type Description <code>InteractionNotFoundError</code> <p>When no matching interaction exists and mode is replay, or when mode is auto but no live_responder is configured.</p> <code>LiveResponderRequiredError</code> <p>When mode is record but no live_responder is configured.</p> Source code in <code>src/interposition/services.py</code> <pre><code>def replay(self, request: InteractionRequest) -&gt; Iterator[ResponseChunk]:\n    \"\"\"Replay recorded response for matching request.\n\n    Args:\n        request: The request to match and replay\n\n    Yields:\n        ResponseChunks in original recorded order\n\n    Raises:\n        InteractionNotFoundError: When no matching interaction exists\n            and mode is replay, or when mode is auto but no\n            live_responder is configured.\n        LiveResponderRequiredError: When mode is record but no\n            live_responder is configured.\n    \"\"\"\n    # record mode: always forward to live, ignore cassette\n    if self._mode == \"record\":\n        yield from self._forward_and_record(request)\n        return\n\n    # replay/auto mode: try cassette first\n    interaction = self.cassette.find_interaction(request.fingerprint())\n    if interaction is not None:\n        yield from interaction.response_chunks\n        return\n\n    # MISS handling\n    if self._mode == \"replay\":\n        raise InteractionNotFoundError(request)\n\n    # auto mode MISS: forward to live\n    yield from self._forward_and_record(request)\n</code></pre>"},{"location":"api/api_reference/#cassettestore","title":"CassetteStore","text":"<p>               Bases: <code>Protocol</code></p> <p>Port for cassette persistence operations.</p> <p>Implementations handle loading and saving cassettes to storage. The Broker calls save() automatically after recording new interactions.</p> Source code in <code>src/interposition/services.py</code> <pre><code>class CassetteStore(Protocol):\n    \"\"\"Port for cassette persistence operations.\n\n    Implementations handle loading and saving cassettes to storage.\n    The Broker calls save() automatically after recording new interactions.\n    \"\"\"\n\n    def load(self) -&gt; Cassette:\n        \"\"\"Load cassette from storage.\n\n        Returns:\n            The loaded Cassette instance.\n        \"\"\"\n        ...\n\n    def save(self, cassette: Cassette) -&gt; None:\n        \"\"\"Save cassette to storage.\n\n        Args:\n            cassette: The cassette to persist.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api/api_reference/#interposition.services.CassetteStore.load","title":"load","text":"<pre><code>load() -&gt; Cassette\n</code></pre> <p>Load cassette from storage.</p> <p>Returns:</p> Type Description <code>Cassette</code> <p>The loaded Cassette instance.</p> Source code in <code>src/interposition/services.py</code> <pre><code>def load(self) -&gt; Cassette:\n    \"\"\"Load cassette from storage.\n\n    Returns:\n        The loaded Cassette instance.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/api_reference/#interposition.services.CassetteStore.save","title":"save","text":"<pre><code>save(cassette: Cassette) -&gt; None\n</code></pre> <p>Save cassette to storage.</p> <p>Parameters:</p> Name Type Description Default <code>cassette</code> <code>Cassette</code> <p>The cassette to persist.</p> required Source code in <code>src/interposition/services.py</code> <pre><code>def save(self, cassette: Cassette) -&gt; None:\n    \"\"\"Save cassette to storage.\n\n    Args:\n        cassette: The cassette to persist.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/api_reference/#stores","title":"Stores","text":""},{"location":"api/api_reference/#jsonfilecassettestore","title":"JsonFileCassetteStore","text":"<p>File-based cassette store using JSON format.</p> <p>Attributes:</p> Name Type Description <code>path</code> <code>Path</code> <p>Path to the JSON file for cassette storage.</p> Source code in <code>src/interposition/stores.py</code> <pre><code>class JsonFileCassetteStore:\n    \"\"\"File-based cassette store using JSON format.\n\n    Attributes:\n        path: Path to the JSON file for cassette storage.\n    \"\"\"\n\n    def __init__(self, path: Path) -&gt; None:\n        \"\"\"Initialize store with file path.\n\n        Args:\n            path: Path to the JSON file (will be created if doesn't exist).\n        \"\"\"\n        self._path = path\n\n    @property\n    def path(self) -&gt; Path:\n        \"\"\"Get the file path.\"\"\"\n        return self._path\n\n    def load(self) -&gt; Cassette:\n        \"\"\"Load cassette from JSON file.\n\n        Returns:\n            Cassette instance loaded from file.\n\n        Raises:\n            FileNotFoundError: If file doesn't exist.\n            pydantic.ValidationError: If JSON is invalid.\n        \"\"\"\n        json_str = self._path.read_text(encoding=\"utf-8\")\n        return Cassette.model_validate_json(json_str)\n\n    def save(self, cassette: Cassette) -&gt; None:\n        \"\"\"Save cassette to JSON file.\n\n        Creates parent directories if they don't exist.\n\n        Args:\n            cassette: The cassette to persist.\n\n        Raises:\n            CassetteSaveError: If file write fails.\n        \"\"\"\n        try:\n            self._path.parent.mkdir(parents=True, exist_ok=True)\n            json_str = cassette.model_dump_json(indent=2)\n            self._path.write_text(json_str, encoding=\"utf-8\")\n        except OSError as e:\n            raise CassetteSaveError(self._path, e) from e\n</code></pre>"},{"location":"api/api_reference/#interposition.stores.JsonFileCassetteStore.path","title":"path  <code>property</code>","text":"<pre><code>path: Path\n</code></pre> <p>Get the file path.</p>"},{"location":"api/api_reference/#interposition.stores.JsonFileCassetteStore.__init__","title":"__init__","text":"<pre><code>__init__(path: Path) -&gt; None\n</code></pre> <p>Initialize store with file path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the JSON file (will be created if doesn't exist).</p> required Source code in <code>src/interposition/stores.py</code> <pre><code>def __init__(self, path: Path) -&gt; None:\n    \"\"\"Initialize store with file path.\n\n    Args:\n        path: Path to the JSON file (will be created if doesn't exist).\n    \"\"\"\n    self._path = path\n</code></pre>"},{"location":"api/api_reference/#interposition.stores.JsonFileCassetteStore.load","title":"load","text":"<pre><code>load() -&gt; Cassette\n</code></pre> <p>Load cassette from JSON file.</p> <p>Returns:</p> Type Description <code>Cassette</code> <p>Cassette instance loaded from file.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist.</p> <code>ValidationError</code> <p>If JSON is invalid.</p> Source code in <code>src/interposition/stores.py</code> <pre><code>def load(self) -&gt; Cassette:\n    \"\"\"Load cassette from JSON file.\n\n    Returns:\n        Cassette instance loaded from file.\n\n    Raises:\n        FileNotFoundError: If file doesn't exist.\n        pydantic.ValidationError: If JSON is invalid.\n    \"\"\"\n    json_str = self._path.read_text(encoding=\"utf-8\")\n    return Cassette.model_validate_json(json_str)\n</code></pre>"},{"location":"api/api_reference/#interposition.stores.JsonFileCassetteStore.save","title":"save","text":"<pre><code>save(cassette: Cassette) -&gt; None\n</code></pre> <p>Save cassette to JSON file.</p> <p>Creates parent directories if they don't exist.</p> <p>Parameters:</p> Name Type Description Default <code>cassette</code> <code>Cassette</code> <p>The cassette to persist.</p> required <p>Raises:</p> Type Description <code>CassetteSaveError</code> <p>If file write fails.</p> Source code in <code>src/interposition/stores.py</code> <pre><code>def save(self, cassette: Cassette) -&gt; None:\n    \"\"\"Save cassette to JSON file.\n\n    Creates parent directories if they don't exist.\n\n    Args:\n        cassette: The cassette to persist.\n\n    Raises:\n        CassetteSaveError: If file write fails.\n    \"\"\"\n    try:\n        self._path.parent.mkdir(parents=True, exist_ok=True)\n        json_str = cassette.model_dump_json(indent=2)\n        self._path.write_text(json_str, encoding=\"utf-8\")\n    except OSError as e:\n        raise CassetteSaveError(self._path, e) from e\n</code></pre>"},{"location":"api/api_reference/#models","title":"Models","text":""},{"location":"api/api_reference/#cassette","title":"Cassette","text":"<p>               Bases: <code>BaseModel</code></p> <p>In-memory collection of recorded interactions.</p> <p>Attributes:</p> Name Type Description <code>interactions</code> <code>tuple[Interaction, ...]</code> <p>Ordered sequence of interactions</p> Source code in <code>src/interposition/models.py</code> <pre><code>class Cassette(BaseModel):\n    \"\"\"In-memory collection of recorded interactions.\n\n    Attributes:\n        interactions: Ordered sequence of interactions\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    interactions: tuple[Interaction, ...]\n    _index: dict[RequestFingerprint, int] = PrivateAttr(default_factory=dict)\n\n    @model_validator(mode=\"after\")\n    def build_index(self) -&gt; Self:\n        \"\"\"Build fingerprint index for efficient lookup.\"\"\"\n        index: dict[RequestFingerprint, int] = {}\n        for i, interaction in enumerate(self.interactions):\n            # Only store first occurrence of each fingerprint\n            if interaction.fingerprint not in index:\n                index[interaction.fingerprint] = i\n        # Use object.__setattr__ to modify frozen model\n        object.__setattr__(self, \"_index\", index)\n        return self\n\n    def find_interaction(self, fingerprint: RequestFingerprint) -&gt; Interaction | None:\n        \"\"\"Find first interaction matching fingerprint.\n\n        Args:\n            fingerprint: Request fingerprint to search for\n\n        Returns:\n            Matching Interaction or None if not found\n        \"\"\"\n        position = self._index.get(fingerprint)\n        if position is None:\n            return None\n        return self.interactions[position]\n</code></pre>"},{"location":"api/api_reference/#interposition.models.Cassette.build_index","title":"build_index","text":"<pre><code>build_index() -&gt; Self\n</code></pre> <p>Build fingerprint index for efficient lookup.</p> Source code in <code>src/interposition/models.py</code> <pre><code>@model_validator(mode=\"after\")\ndef build_index(self) -&gt; Self:\n    \"\"\"Build fingerprint index for efficient lookup.\"\"\"\n    index: dict[RequestFingerprint, int] = {}\n    for i, interaction in enumerate(self.interactions):\n        # Only store first occurrence of each fingerprint\n        if interaction.fingerprint not in index:\n            index[interaction.fingerprint] = i\n    # Use object.__setattr__ to modify frozen model\n    object.__setattr__(self, \"_index\", index)\n    return self\n</code></pre>"},{"location":"api/api_reference/#interposition.models.Cassette.find_interaction","title":"find_interaction","text":"<pre><code>find_interaction(\n    fingerprint: RequestFingerprint,\n) -&gt; Interaction | None\n</code></pre> <p>Find first interaction matching fingerprint.</p> <p>Parameters:</p> Name Type Description Default <code>fingerprint</code> <code>RequestFingerprint</code> <p>Request fingerprint to search for</p> required <p>Returns:</p> Type Description <code>Interaction | None</code> <p>Matching Interaction or None if not found</p> Source code in <code>src/interposition/models.py</code> <pre><code>def find_interaction(self, fingerprint: RequestFingerprint) -&gt; Interaction | None:\n    \"\"\"Find first interaction matching fingerprint.\n\n    Args:\n        fingerprint: Request fingerprint to search for\n\n    Returns:\n        Matching Interaction or None if not found\n    \"\"\"\n    position = self._index.get(fingerprint)\n    if position is None:\n        return None\n    return self.interactions[position]\n</code></pre>"},{"location":"api/api_reference/#interaction","title":"Interaction","text":"<p>               Bases: <code>BaseModel</code></p> <p>Complete request-response pair for replay.</p> <p>Attributes:</p> Name Type Description <code>request</code> <code>InteractionRequest</code> <p>The original InteractionRequest</p> <code>fingerprint</code> <code>RequestFingerprint</code> <p>Precomputed request fingerprint for matching</p> <code>response_chunks</code> <code>tuple[ResponseChunk, ...]</code> <p>Ordered sequence of response chunks</p> <code>metadata</code> <code>tuple[tuple[str, str], ...]</code> <p>Optional interaction metadata as (key, value) pairs. Examples: recording timestamp, session ID, test scenario name. Useful for debugging and tracing recorded interactions. Default is empty tuple.</p> Source code in <code>src/interposition/models.py</code> <pre><code>class Interaction(BaseModel):\n    \"\"\"Complete request-response pair for replay.\n\n    Attributes:\n        request: The original InteractionRequest\n        fingerprint: Precomputed request fingerprint for matching\n        response_chunks: Ordered sequence of response chunks\n        metadata: Optional interaction metadata as (key, value) pairs.\n            Examples: recording timestamp, session ID, test scenario name.\n            Useful for debugging and tracing recorded interactions.\n            Default is empty tuple.\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    request: InteractionRequest\n    fingerprint: RequestFingerprint\n    response_chunks: tuple[ResponseChunk, ...]\n    metadata: tuple[tuple[str, str], ...] = ()\n\n    @model_validator(mode=\"after\")\n    def validate_interaction(self) -&gt; Self:\n        \"\"\"Validate interaction integrity.\n\n        Raises:\n            InteractionValidationError: If fingerprint doesn't match request\n                or chunks aren't sequential\n        \"\"\"\n        # Verify fingerprint matches request\n        expected_fingerprint = self.request.fingerprint()\n        if self.fingerprint != expected_fingerprint:\n            msg = (\n                f\"Fingerprint does not match request: \"\n                f\"expected {expected_fingerprint.value}, got {self.fingerprint.value}\"\n            )\n            raise InteractionValidationError(msg)\n\n        # Verify response chunks are sequentially ordered\n        if not self.response_chunks:\n            msg = \"Response chunks cannot be empty\"\n            raise InteractionValidationError(msg)\n\n        if self.response_chunks[0].sequence != 0:\n            msg = \"Response chunks must start at sequence 0\"\n            raise InteractionValidationError(msg)\n\n        for i, chunk in enumerate(self.response_chunks):\n            if chunk.sequence != i:\n                msg = \"Response chunks must be sequential with no gaps\"\n                raise InteractionValidationError(msg)\n\n        return self\n</code></pre>"},{"location":"api/api_reference/#interposition.models.Interaction.validate_interaction","title":"validate_interaction","text":"<pre><code>validate_interaction() -&gt; Self\n</code></pre> <p>Validate interaction integrity.</p> <p>Raises:</p> Type Description <code>InteractionValidationError</code> <p>If fingerprint doesn't match request or chunks aren't sequential</p> Source code in <code>src/interposition/models.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_interaction(self) -&gt; Self:\n    \"\"\"Validate interaction integrity.\n\n    Raises:\n        InteractionValidationError: If fingerprint doesn't match request\n            or chunks aren't sequential\n    \"\"\"\n    # Verify fingerprint matches request\n    expected_fingerprint = self.request.fingerprint()\n    if self.fingerprint != expected_fingerprint:\n        msg = (\n            f\"Fingerprint does not match request: \"\n            f\"expected {expected_fingerprint.value}, got {self.fingerprint.value}\"\n        )\n        raise InteractionValidationError(msg)\n\n    # Verify response chunks are sequentially ordered\n    if not self.response_chunks:\n        msg = \"Response chunks cannot be empty\"\n        raise InteractionValidationError(msg)\n\n    if self.response_chunks[0].sequence != 0:\n        msg = \"Response chunks must start at sequence 0\"\n        raise InteractionValidationError(msg)\n\n    for i, chunk in enumerate(self.response_chunks):\n        if chunk.sequence != i:\n            msg = \"Response chunks must be sequential with no gaps\"\n            raise InteractionValidationError(msg)\n\n    return self\n</code></pre>"},{"location":"api/api_reference/#interactionrequest","title":"InteractionRequest","text":"<p>               Bases: <code>BaseModel</code></p> <p>Structured representation of a protocol-agnostic request.</p> <p>Attributes:</p> Name Type Description <code>protocol</code> <code>str</code> <p>Protocol identifier (e.g., \"grpc\", \"graphql\", \"mqtt\")</p> <code>action</code> <code>str</code> <p>Action/method name (e.g., \"ListUsers\", \"query\", \"publish\")</p> <code>target</code> <code>str</code> <p>Target resource (e.g., \"users.UserService\", \"topic/sensors\")</p> <code>headers</code> <code>tuple[tuple[str, str], ...]</code> <p>Request headers as immutable sequence of key-value pairs</p> <code>body</code> <code>bytes</code> <p>Request body content as bytes</p> Source code in <code>src/interposition/models.py</code> <pre><code>class InteractionRequest(BaseModel):\n    \"\"\"Structured representation of a protocol-agnostic request.\n\n    Attributes:\n        protocol: Protocol identifier (e.g., \"grpc\", \"graphql\", \"mqtt\")\n        action: Action/method name (e.g., \"ListUsers\", \"query\", \"publish\")\n        target: Target resource (e.g., \"users.UserService\", \"topic/sensors\")\n        headers: Request headers as immutable sequence of key-value pairs\n        body: Request body content as bytes\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    protocol: str\n    action: str\n    target: str\n    headers: tuple[tuple[str, str], ...]\n    body: bytes\n\n    def fingerprint(self) -&gt; RequestFingerprint:\n        \"\"\"Generate stable fingerprint for efficient matching.\n\n        Returns:\n            RequestFingerprint derived from all request fields.\n        \"\"\"\n        return RequestFingerprint.from_request(self)\n</code></pre>"},{"location":"api/api_reference/#interposition.models.InteractionRequest.fingerprint","title":"fingerprint","text":"<pre><code>fingerprint() -&gt; RequestFingerprint\n</code></pre> <p>Generate stable fingerprint for efficient matching.</p> <p>Returns:</p> Type Description <code>RequestFingerprint</code> <p>RequestFingerprint derived from all request fields.</p> Source code in <code>src/interposition/models.py</code> <pre><code>def fingerprint(self) -&gt; RequestFingerprint:\n    \"\"\"Generate stable fingerprint for efficient matching.\n\n    Returns:\n        RequestFingerprint derived from all request fields.\n    \"\"\"\n    return RequestFingerprint.from_request(self)\n</code></pre>"},{"location":"api/api_reference/#responsechunk","title":"ResponseChunk","text":"<p>               Bases: <code>BaseModel</code></p> <p>Discrete piece of response data.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>bytes</code> <p>Chunk payload as bytes</p> <code>sequence</code> <code>int</code> <p>Zero-based chunk position in response stream</p> <code>metadata</code> <code>tuple[tuple[str, str], ...]</code> <p>Optional chunk metadata as (key, value) string pairs. Examples: timing info, encoding, content-type for this chunk. Default is empty tuple.</p> Source code in <code>src/interposition/models.py</code> <pre><code>class ResponseChunk(BaseModel):\n    \"\"\"Discrete piece of response data.\n\n    Attributes:\n        data: Chunk payload as bytes\n        sequence: Zero-based chunk position in response stream\n        metadata: Optional chunk metadata as (key, value) string pairs.\n            Examples: timing info, encoding, content-type for this chunk.\n            Default is empty tuple.\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    data: bytes\n    sequence: int\n    metadata: tuple[tuple[str, str], ...] = ()\n</code></pre>"},{"location":"api/api_reference/#requestfingerprint","title":"RequestFingerprint","text":"<p>               Bases: <code>BaseModel</code></p> <p>Stable unique identifier for request matching.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>str</code> <p>SHA-256 hash of canonicalized request fields</p> Source code in <code>src/interposition/models.py</code> <pre><code>class RequestFingerprint(BaseModel):\n    \"\"\"Stable unique identifier for request matching.\n\n    Attributes:\n        value: SHA-256 hash of canonicalized request fields\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    value: str\n\n    @field_validator(\"value\")\n    @classmethod\n    def validate_sha256_hex(cls, v: str) -&gt; str:\n        \"\"\"Validate that value is a valid SHA-256 hex string.\n\n        Args:\n            v: The fingerprint value to validate\n\n        Returns:\n            The validated value\n\n        Raises:\n            ValueError: If value is not exactly 64 hex characters\n        \"\"\"\n        if len(v) != SHA256_HEX_LENGTH:\n            msg = f\"SHA-256 hex must be exactly {SHA256_HEX_LENGTH} characters\"\n            raise ValueError(msg)\n        if not all(c in \"0123456789abcdef\" for c in v):\n            msg = \"Invalid hex characters in fingerprint\"\n            raise ValueError(msg)\n        return v\n\n    @classmethod\n    def from_request(cls, request: InteractionRequest) -&gt; Self:\n        \"\"\"Create fingerprint from InteractionRequest.\n\n        Args:\n            request: The request to fingerprint\n\n        Returns:\n            RequestFingerprint with SHA-256 hash value\n        \"\"\"\n        # Canonical order: protocol, action, target, headers, body\n        # Preserve header ordering to avoid normalization.\n        canonical_data = [\n            request.protocol,\n            request.action,\n            request.target,\n            request.headers,\n            request.body.hex(),\n        ]\n        canonical = json.dumps(\n            canonical_data,\n            separators=_CANONICAL_JSON_SEPARATORS,\n            sort_keys=_CANONICAL_JSON_SORT_KEYS,\n        )\n        hash_value = hashlib.sha256(canonical.encode(\"utf-8\")).hexdigest()\n        return cls(value=hash_value)\n</code></pre>"},{"location":"api/api_reference/#interposition.models.RequestFingerprint.validate_sha256_hex","title":"validate_sha256_hex  <code>classmethod</code>","text":"<pre><code>validate_sha256_hex(v: str) -&gt; str\n</code></pre> <p>Validate that value is a valid SHA-256 hex string.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>The fingerprint value to validate</p> required <p>Returns:</p> Type Description <code>str</code> <p>The validated value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If value is not exactly 64 hex characters</p> Source code in <code>src/interposition/models.py</code> <pre><code>@field_validator(\"value\")\n@classmethod\ndef validate_sha256_hex(cls, v: str) -&gt; str:\n    \"\"\"Validate that value is a valid SHA-256 hex string.\n\n    Args:\n        v: The fingerprint value to validate\n\n    Returns:\n        The validated value\n\n    Raises:\n        ValueError: If value is not exactly 64 hex characters\n    \"\"\"\n    if len(v) != SHA256_HEX_LENGTH:\n        msg = f\"SHA-256 hex must be exactly {SHA256_HEX_LENGTH} characters\"\n        raise ValueError(msg)\n    if not all(c in \"0123456789abcdef\" for c in v):\n        msg = \"Invalid hex characters in fingerprint\"\n        raise ValueError(msg)\n    return v\n</code></pre>"},{"location":"api/api_reference/#interposition.models.RequestFingerprint.from_request","title":"from_request  <code>classmethod</code>","text":"<pre><code>from_request(request: InteractionRequest) -&gt; Self\n</code></pre> <p>Create fingerprint from InteractionRequest.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>InteractionRequest</code> <p>The request to fingerprint</p> required <p>Returns:</p> Type Description <code>Self</code> <p>RequestFingerprint with SHA-256 hash value</p> Source code in <code>src/interposition/models.py</code> <pre><code>@classmethod\ndef from_request(cls, request: InteractionRequest) -&gt; Self:\n    \"\"\"Create fingerprint from InteractionRequest.\n\n    Args:\n        request: The request to fingerprint\n\n    Returns:\n        RequestFingerprint with SHA-256 hash value\n    \"\"\"\n    # Canonical order: protocol, action, target, headers, body\n    # Preserve header ordering to avoid normalization.\n    canonical_data = [\n        request.protocol,\n        request.action,\n        request.target,\n        request.headers,\n        request.body.hex(),\n    ]\n    canonical = json.dumps(\n        canonical_data,\n        separators=_CANONICAL_JSON_SEPARATORS,\n        sort_keys=_CANONICAL_JSON_SORT_KEYS,\n    )\n    hash_value = hashlib.sha256(canonical.encode(\"utf-8\")).hexdigest()\n    return cls(value=hash_value)\n</code></pre>"},{"location":"api/api_reference/#exceptions","title":"Exceptions","text":""},{"location":"api/api_reference/#interpositionerror","title":"InterpositionError","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all interposition exceptions.</p> Source code in <code>src/interposition/errors.py</code> <pre><code>class InterpositionError(Exception):\n    \"\"\"Base class for all interposition exceptions.\"\"\"\n</code></pre>"},{"location":"api/api_reference/#cassettesaveerror","title":"CassetteSaveError","text":"<p>               Bases: <code>InterpositionError</code></p> <p>Raised when cassette persistence fails.</p> Source code in <code>src/interposition/errors.py</code> <pre><code>class CassetteSaveError(InterpositionError):\n    \"\"\"Raised when cassette persistence fails.\"\"\"\n\n    def __init__(self, path: Path, cause: Exception) -&gt; None:\n        \"\"\"Initialize with the path and underlying cause.\n\n        Args:\n            path: The file path where save failed\n            cause: The underlying exception that caused the failure\n        \"\"\"\n        super().__init__(f\"Failed to save cassette to {path}: {cause}\")\n        self.path: Path = path\n        self.__cause__ = cause\n</code></pre>"},{"location":"api/api_reference/#interposition.errors.CassetteSaveError.__init__","title":"__init__","text":"<pre><code>__init__(path: Path, cause: Exception) -&gt; None\n</code></pre> <p>Initialize with the path and underlying cause.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The file path where save failed</p> required <code>cause</code> <code>Exception</code> <p>The underlying exception that caused the failure</p> required Source code in <code>src/interposition/errors.py</code> <pre><code>def __init__(self, path: Path, cause: Exception) -&gt; None:\n    \"\"\"Initialize with the path and underlying cause.\n\n    Args:\n        path: The file path where save failed\n        cause: The underlying exception that caused the failure\n    \"\"\"\n    super().__init__(f\"Failed to save cassette to {path}: {cause}\")\n    self.path: Path = path\n    self.__cause__ = cause\n</code></pre>"},{"location":"api/api_reference/#interactionnotfounderror","title":"InteractionNotFoundError","text":"<p>               Bases: <code>InterpositionError</code></p> <p>Raised when no matching interaction is found in cassette.</p> Source code in <code>src/interposition/errors.py</code> <pre><code>class InteractionNotFoundError(InterpositionError):\n    \"\"\"Raised when no matching interaction is found in cassette.\"\"\"\n\n    def __init__(self, request: InteractionRequest) -&gt; None:\n        \"\"\"Initialize with request that failed to match.\n\n        Args:\n            request: The unmatched request\n        \"\"\"\n        super().__init__(\n            f\"No matching interaction for {request.protocol}:\"\n            f\"{request.action}:{request.target}\"\n        )\n        self.request: InteractionRequest = request\n</code></pre>"},{"location":"api/api_reference/#interposition.errors.InteractionNotFoundError.__init__","title":"__init__","text":"<pre><code>__init__(request: InteractionRequest) -&gt; None\n</code></pre> <p>Initialize with request that failed to match.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>InteractionRequest</code> <p>The unmatched request</p> required Source code in <code>src/interposition/errors.py</code> <pre><code>def __init__(self, request: InteractionRequest) -&gt; None:\n    \"\"\"Initialize with request that failed to match.\n\n    Args:\n        request: The unmatched request\n    \"\"\"\n    super().__init__(\n        f\"No matching interaction for {request.protocol}:\"\n        f\"{request.action}:{request.target}\"\n    )\n    self.request: InteractionRequest = request\n</code></pre>"},{"location":"api/api_reference/#interactionvalidationerror","title":"InteractionValidationError","text":"<p>               Bases: <code>InterpositionError</code>, <code>ValueError</code></p> <p>Raised when interaction validation fails.</p> Source code in <code>src/interposition/models.py</code> <pre><code>class InteractionValidationError(InterpositionError, ValueError):\n    \"\"\"Raised when interaction validation fails.\"\"\"\n</code></pre>"},{"location":"api/api_reference/#liveresponderrequirederror","title":"LiveResponderRequiredError","text":"<p>               Bases: <code>InterpositionError</code></p> <p>Raised when live_responder is required but not configured.</p> Source code in <code>src/interposition/errors.py</code> <pre><code>class LiveResponderRequiredError(InterpositionError):\n    \"\"\"Raised when live_responder is required but not configured.\"\"\"\n\n    def __init__(self, mode: str) -&gt; None:\n        \"\"\"Initialize with the mode that requires live_responder.\n\n        Args:\n            mode: The broker mode that requires live_responder\n        \"\"\"\n        super().__init__(f\"live_responder is required for {mode} mode\")\n        self.mode: str = mode\n</code></pre>"},{"location":"api/api_reference/#interposition.errors.LiveResponderRequiredError.__init__","title":"__init__","text":"<pre><code>__init__(mode: str) -&gt; None\n</code></pre> <p>Initialize with the mode that requires live_responder.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>str</code> <p>The broker mode that requires live_responder</p> required Source code in <code>src/interposition/errors.py</code> <pre><code>def __init__(self, mode: str) -&gt; None:\n    \"\"\"Initialize with the mode that requires live_responder.\n\n    Args:\n        mode: The broker mode that requires live_responder\n    \"\"\"\n    super().__init__(f\"live_responder is required for {mode} mode\")\n    self.mode: str = mode\n</code></pre>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>This document provides a high-level overview of architectural decisions made for the interposition project.</p>"},{"location":"architecture/overview/#architecture-decision-records","title":"Architecture Decision Records","text":""},{"location":"architecture/overview/#adr-0001-use-pydantic-v2-for-data-models","title":"ADR-0001: Use Pydantic v2 for Data Models","text":"<p>Status: Accepted | Date: 2026-01-05</p> <p>Use Pydantic v2 BaseModel for all data models to enable serialization, runtime validation, and immutability without custom code.</p>"},{"location":"architecture/overview/#adr-0002-use-sha-256-for-request-fingerprinting","title":"ADR-0002: Use SHA-256 for Request Fingerprinting","text":"<p>Status: Accepted | Date: 2026-01-05</p> <p>Use SHA-256 hash of canonicalized request fields as fingerprints for efficient and collision-resistant interaction matching.</p>"},{"location":"architecture/overview/#adr-0003-use-generator-pattern-for-response-streaming","title":"ADR-0003: Use Generator Pattern for Response Streaming","text":"<p>Status: Accepted | Date: 2026-01-05</p> <p>Use Python generators for streaming response chunks to enable lazy evaluation, memory efficiency, and backpressure support.</p>"},{"location":"architecture/overview/#adr-0004-use-first-match-strategy-for-duplicate-interactions","title":"ADR-0004: Use First-Match Strategy for Duplicate Interactions","text":"<p>Status: Accepted | Date: 2026-01-05</p> <p>When multiple interactions have identical fingerprints, return the first match to ensure deterministic and predictable replay behavior.</p>"},{"location":"architecture/overview/#adr-0005-build-fingerprint-index-for-o1-lookup","title":"ADR-0005: Build Fingerprint Index for O(1) Lookup","text":"<p>Status: Accepted | Date: 2026-01-05</p> <p>Build an in-memory hash map index from fingerprints to interaction positions at cassette construction time for O(1) lookup performance.</p>"},{"location":"architecture/overview/#adr-0006-external-protocol-adapters-strategy","title":"ADR-0006: External Protocol Adapters Strategy","text":"<p>Status: Accepted | Date: 2026-01-10</p> <p>Keep protocol-specific adapters external to the core package. Users implement adapters suited to their integration strategy (monkey patching, proxy servers, etc.).</p>"},{"location":"architecture/overview/#adr-0007-broker-mode-parameter-for-record-functionality","title":"ADR-0007: Broker Mode Parameter for Record Functionality","text":"<p>Status: Accepted | Date: 2026-01-25</p> <p>Add a mode parameter to the Broker class (replay, record, auto) to determine replay vs. live-forward behavior, enabling record functionality.</p>"},{"location":"architecture/overview/#adr-0008-use-literal-type-for-broker-mode-values","title":"ADR-0008: Use Literal Type for Broker Mode Values","text":"<p>Status: Accepted | Date: 2026-01-25</p> <p>Use typing.Literal with a type alias for broker mode values instead of Enum, for simplicity and Pydantic compatibility.</p>"},{"location":"architecture/overview/#adr-0009-liveresponder-port-for-upstream-forwarding","title":"ADR-0009: LiveResponder Port for Upstream Forwarding","text":"<p>Status: Accepted | Date: 2026-01-25</p> <p>Define LiveResponder as a callable port (<code>Callable[[InteractionRequest], Iterable[ResponseChunk]]</code>) for protocol-agnostic upstream communication.</p>"},{"location":"architecture/overview/#adr-0010-buffer-live-responses-before-recording","title":"ADR-0010: Buffer Live Responses Before Recording","text":"<p>Status: Accepted | Date: 2026-01-25</p> <p>When forwarding in record/auto mode, fully collect live response chunks before returning any data, then record and return the buffered response.</p>"},{"location":"architecture/overview/#adr-0011-cassettestore-persistence-port","title":"ADR-0011: CassetteStore Persistence Port","text":"<p>Status: Accepted | Date: 2026-01-30</p> <p>Define CassetteStore as a Protocol port with load() and save() methods for storage-agnostic cassette persistence with automatic save on record.</p>"},{"location":"architecture/overview/#adr-0012-cassette-save-failure-behavior","title":"ADR-0012: Cassette Save Failure Behavior","text":"<p>Status: Accepted | Date: 2026-01-31</p> <p>Define fail-fast behavior when cassette persistence fails (save errors are propagated and response streaming stops).</p>"},{"location":"guides/adapters/","title":"Protocol Adapters Guide","text":"<p>Interposition is a pure logic engine. It knows how to store and match interactions, but it doesn't know how to talk to the network or your database.</p> <p>To bridge this gap, you use Adapters.</p>"},{"location":"guides/adapters/#what-is-an-adapter","title":"What is an Adapter?","text":"<p>An Adapter is a piece of code that sits between your application (or its libraries) and Interposition.</p> <p>Its responsibilities are: 1.  Intercept: Catch the outgoing request (HTTP, SQL, etc.). 2.  Translate: Convert that request into an <code>InteractionRequest</code>. 3.  Delegate: Ask the Interposition <code>Broker</code> for a response. 4.  Return: Convert the <code>ResponseChunk</code>s back into the native response format (e.g., <code>requests.Response</code> or SQL rows).</p>"},{"location":"guides/adapters/#implementation-strategies","title":"Implementation Strategies","text":"<p>There are two main ways to implement an adapter, depending on your testing needs.</p>"},{"location":"guides/adapters/#1-monkey-patching-internal","title":"1. Monkey Patching (Internal)","text":"<p>Best for: Unit Tests, Python-only projects, No Dependencies.</p> <p>In this strategy, you replace a library's internal method (like <code>urllib.request.OpenerDirector.open</code> or <code>sqlalchemy.engine.Connection.execute</code>) with your own function or handler.</p> <p>Pros: *   Fast and lightweight. *   No need to change application configuration (URLs). *   Zero external dependencies (if using standard library).</p> <p>Cons: *   Only works for Python code running in the same process. *   Relies on library internals.</p> <p>\ud83d\udc49 See Example: urllib Adapter</p>"},{"location":"guides/adapters/#2-proxy-server-external","title":"2. Proxy Server (External)","text":"<p>Best for: E2E Tests, External Processes, Non-Python Clients.</p> <p>In this strategy, you run a small server (a proxy) that Interposition controls. You configure your application to send traffic to this proxy.</p> <p>Pros: *   Language Agnostic: Works with <code>curl</code>, Node.js, Go, etc. *   Process Agnostic: Works even if your app runs in a separate Docker container. *   Clean: Does not mess with library internals.</p> <p>Cons: *   Requires changing application config (e.g., setting <code>HTTP_PROXY</code>). *   Slightly more complex setup.</p> <p>\ud83d\udc49 See Example: HTTP Proxy Server</p>"},{"location":"guides/adapters/#why-arent-adapters-included","title":"Why aren't adapters included?","text":"<p>We decided not to include built-in adapters (like <code>interposition.adapters.requests</code>) in the core package.  See ADR 0006: External Protocol Adapters for the detailed reasoning.</p> <p>In short: We want to keep the core lightweight and protocol-agnostic. By copying the examples and modifying them, you get full control over exactly how the interception happens.</p>"},{"location":"guides/specifications/","title":"Specifications","text":"<p>This page shows the executable specifications (E2E tests) for interposition. These specifications serve as living documentation - they are always in sync with the actual behavior.</p>"},{"location":"guides/specifications/#record-specification","title":"Record specification","text":""},{"location":"guides/specifications/#broker-raises-error-for-miss-in-replay-mode","title":"Broker raises error for MISS in replay mode","text":"<ul> <li>Create empty cassette</li> <li>Broker in \"replay\" mode receives request for \"test-proto\" \"fetch\" \"resource-123\"</li> <li>Broker should raise InteractionNotFoundError</li> </ul>"},{"location":"guides/specifications/#broker-forwards-miss-to-live-upstream-in-auto-mode","title":"Broker forwards MISS to live upstream in auto mode","text":"<ul> <li>Create empty cassette</li> <li>Configure mock live responder returning \"live-response-data\"</li> <li>Broker in \"auto\" mode receives request for \"test-proto\" \"fetch\" \"resource-123\"</li> <li>Response stream should contain \"live-response-data\"</li> <li>Cassette should contain one recorded interaction</li> </ul>"},{"location":"guides/specifications/#broker-forwards-miss-to-live-upstream-in-record-mode","title":"Broker forwards MISS to live upstream in record mode","text":"<ul> <li>Create empty cassette</li> <li>Configure mock live responder returning \"live-response-data\"</li> <li>Broker in \"record\" mode receives request for \"test-proto\" \"fetch\" \"resource-123\"</li> <li>Response stream should contain \"live-response-data\"</li> <li>Cassette should contain one recorded interaction</li> </ul>"},{"location":"guides/specifications/#broker-does-not-forward-hit-in-auto-mode","title":"Broker does not forward HIT in auto mode","text":"<ul> <li>Create cassette with recorded interaction for \"test-proto\" \"fetch\" \"resource-123\"</li> <li>Configure tracking live responder returning \"live-response-data\"</li> <li>Broker in \"auto\" mode receives request for \"test-proto\" \"fetch\" \"resource-123\"</li> <li>Response stream should contain recorded chunks in order</li> <li>Live responder should not be called</li> </ul>"},{"location":"guides/specifications/#broker-always-forwards-to-live-in-record-mode-even-on-hit","title":"Broker always forwards to live in record mode even on HIT","text":"<ul> <li>Create cassette with recorded interaction for \"test-proto\" \"fetch\" \"resource-123\"</li> <li>Configure tracking live responder returning \"fresh-live-data\"</li> <li>Broker in \"record\" mode receives request for \"test-proto\" \"fetch\" \"resource-123\"</li> <li>Live responder should be called</li> <li>Response stream should contain \"fresh-live-data\"</li> </ul>"},{"location":"guides/specifications/#recorded-cassette-can-be-serialized-and-replayed","title":"Recorded cassette can be serialized and replayed","text":"<ul> <li>Create empty cassette</li> <li>Configure mock live responder returning \"recorded-data\"</li> <li>Broker in \"auto\" mode receives request for \"test-proto\" \"fetch\" \"resource-123\"</li> <li>Serialize and deserialize cassette</li> <li>Broker in \"replay\" mode receives request for \"test-proto\" \"fetch\" \"resource-123\"</li> <li>Response stream should contain \"recorded-data\"</li> </ul>"},{"location":"guides/specifications/#replay-specification","title":"Replay specification","text":""},{"location":"guides/specifications/#broker-replays-matching-interaction","title":"Broker replays matching interaction","text":"<ul> <li>Create cassette with recorded interaction for \"test-proto\" \"fetch\" \"resource-123\"</li> <li>Broker receives identical request for \"test-proto\" \"fetch\" \"resource-123\"</li> <li>Response stream should contain recorded chunks in order</li> <li>Response stream should complete without errors</li> </ul>"},{"location":"guides/specifications/#broker-raises-error-for-unmatched-request","title":"Broker raises error for unmatched request","text":"<ul> <li>Create cassette with recorded interaction for \"test-proto\" \"fetch\" \"resource-123\"</li> <li>Broker receives different request for \"test-proto\" \"store\" \"resource-456\"</li> <li>Broker should raise InteractionNotFoundError</li> </ul>"},{"location":"guides/specifications/#broker-returns-first-matching-interaction","title":"Broker returns first matching interaction","text":"<ul> <li>Create cassette with two identical interactions for \"test-proto\" \"fetch\" \"resource-123\"</li> <li>Broker receives request for \"test-proto\" \"fetch\" \"resource-123\"</li> <li>Response stream should contain chunks from FIRST recorded interaction</li> </ul>"},{"location":"guides/specifications/#broker-treats-header-order-as-significant","title":"Broker treats header order as significant","text":"<ul> <li>Create cassette with recorded interaction headers \"X-First:1,X-Second:2\"</li> <li>Broker receives request with headers \"X-Second:2,X-First:1\"</li> <li>Broker should raise InteractionNotFoundError</li> </ul>"}]}