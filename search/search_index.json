{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"interposition","text":"<p>Protocol-agnostic interaction interposition with lifecycle hooks for record, replay, and control.</p>"},{"location":"#overview","title":"Overview","text":"<p>Interposition is a Python library for replaying recorded interactions. Unlike VCRpy or other HTTP-specific tools, Interposition does not automatically hook into network libraries.</p> <p>Instead, it provides a pure logic engine for storage, matching, and replay. You write the adapter for your specific target (HTTP client, database driver, IoT message handler), and Interposition handles the rest.</p> <p>Key Features:</p> <ul> <li>Protocol-agnostic: Works with any protocol (HTTP, gRPC, SQL, Pub/Sub, etc.)</li> <li>Type-safe: Full mypy strict mode support with Pydantic v2</li> <li>Immutable: All data structures are frozen Pydantic models</li> <li>Serializable: Built-in JSON/YAML serialization for cassette persistence</li> <li>Memory-efficient: O(1) lookup with fingerprint indexing</li> <li>Streaming: Generator-based response delivery</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<p>Interposition sits behind your application's data access layer. You provide the \"Adapter\" that captures live traffic or requests replay from the Broker.</p> <pre><code>+-------------+      +------------------+      +---------------+\n| Application | &lt;--&gt; | Your Adapter     | &lt;--&gt; | Interposition |\n+-------------+      +------------------+      +---------------+\n                            |                          |\n                       (Traps calls)              (Manages)\n                                                       |\n                                                  [Cassette]\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install interposition\n</code></pre>"},{"location":"#practical-integration-pytest-recipe","title":"Practical Integration (Pytest Recipe)","text":"<p>The most common use case is using Interposition as a test fixture. Here is a production-ready recipe for <code>pytest</code>:</p> <pre><code>import pytest\nfrom interposition import Broker, Cassette, InteractionRequest\n\n@pytest.fixture\ndef cassette_broker():\n    # Load cassette from a JSON file (or create one programmatically)\n    with open(\"tests/fixtures/my_cassette.json\", \"rb\") as f:\n        cassette = Cassette.model_validate_json(f.read())\n    return Broker(cassette)\n\ndef test_user_service(cassette_broker, monkeypatch):\n    # 1. Create your adapter (mocking your actual client)\n    def mock_fetch(url):\n        request = InteractionRequest(\n            protocol=\"http\",\n            action=\"GET\",\n            target=url,\n            headers=(),\n            body=b\"\",\n        )\n        # Delegate to Interposition\n        chunks = list(cassette_broker.replay(request))\n        return chunks[0].data\n\n    # 2. Inject the adapter\n    monkeypatch.setattr(\"my_app.client.fetch\", mock_fetch)\n\n    # 3. Run your test\n    from my_app import get_user_name\n    assert get_user_name(42) == \"Alice\"\n</code></pre>"},{"location":"#protocol-agnostic-examples","title":"Protocol-Agnostic Examples","text":"<p>Interposition shines where HTTP-only tools fail.</p>"},{"location":"#sql-database-query","title":"SQL Database Query","text":"<pre><code>request = InteractionRequest(\n    protocol=\"postgres\",\n    action=\"SELECT\",\n    target=\"users_table\",\n    headers=(),\n    body=b\"SELECT id, name FROM users WHERE id = 42\",\n)\n# Replay returns: b'[(42, \"Alice\")]'\n</code></pre>"},{"location":"#mqtt-pubsub-message","title":"MQTT / PubSub Message","text":"<pre><code>request = InteractionRequest(\n    protocol=\"mqtt\",\n    action=\"subscribe\",\n    target=\"sensors/temp/room1\",\n    headers=((\"qos\", \"1\"),),\n    body=b\"\",\n)\n# Replay returns stream of messages: b'24.5', b'24.6', ...\n</code></pre>"},{"location":"#usage-guide","title":"Usage Guide","text":""},{"location":"#manual-construction-quick-start","title":"Manual Construction (Quick Start)","text":"<p>If you need to build interactions programmatically (e.g., for seeding tests):</p> <pre><code>from interposition import (\n    Broker,\n    Cassette,\n    Interaction,\n    InteractionRequest,\n    ResponseChunk,\n)\n\n# 1. Define the Request\nrequest = InteractionRequest(\n    protocol=\"api\",\n    action=\"query\",\n    target=\"users/42\",\n    headers=(),\n    body=b\"\",\n)\n\n# 2. Define the Response\nchunks = (\n    ResponseChunk(data=b'{\"id\": 42, \"name\": \"Alice\"}', sequence=0),\n)\n\n# 3. Create Interaction &amp; Cassette\ninteraction = Interaction(\n    request=request,\n    fingerprint=request.fingerprint(),\n    response_chunks=chunks,\n)\ncassette = Cassette(interactions=(interaction,))\n\n# 4. Replay\nbroker = Broker(cassette=cassette)\nresponse = list(broker.replay(request))\n</code></pre>"},{"location":"#persistence-serialization","title":"Persistence &amp; Serialization","text":"<p>Interposition models are Pydantic v2 models, making serialization trivial.</p> <pre><code># Save to JSON\nwith open(\"cassette.json\", \"w\") as f:\n    f.write(cassette.model_dump_json(indent=2))\n\n# Load from JSON\nwith open(\"cassette.json\") as f:\n    cassette = Cassette.model_validate_json(f.read())\n\n# Generate JSON Schema\nschema = Cassette.model_json_schema()\n</code></pre>"},{"location":"#streaming-responses","title":"Streaming Responses","text":"<p>For large files or streaming protocols, responses are yielded lazily:</p> <pre><code># The broker returns a generator\nfor chunk in broker.replay(request):\n    print(f\"Received chunk: {len(chunk.data)} bytes\")\n</code></pre>"},{"location":"#error-handling","title":"Error Handling","text":"<p>If a matching interaction is not found, the broker raises <code>InteractionNotFoundError</code>:</p> <pre><code>from interposition import InteractionNotFoundError\n\ntry:\n    broker.replay(unknown_request)\nexcept InteractionNotFoundError as e:\n    print(f\"Not recorded: {e.request.target}\")\n</code></pre>"},{"location":"#development","title":"Development","text":""},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10+</li> <li>uv (recommended)</li> </ul>"},{"location":"#setup-testing","title":"Setup &amp; Testing","text":"<pre><code># Clone and install\ngit clone https://github.com/osoekawaitlab/interposition.git\ncd interposition\nuv pip install -e . --group=dev\n\n# Run tests\nnox -s tests\n</code></pre>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"adr/0000-adr-template/","title":"ADR 0000: This is ADR Template and Short Title of the Architectural Decision Goes Here","text":""},{"location":"adr/0000-adr-template/#status","title":"Status","text":"<p>[Proposed | Accepted | Deprecated | Superseded]</p>"},{"location":"adr/0000-adr-template/#date","title":"Date","text":"<p>YYYY-MM-DD</p>"},{"location":"adr/0000-adr-template/#context","title":"Context","text":"<p>Describe the context and problem statement. What is the architectural challenge that needs to be addressed? Include any relevant constraints or requirements that influenced the decision.</p>"},{"location":"adr/0000-adr-template/#decision","title":"Decision","text":"<p>State the architectural decision clearly and concisely. What specific approach, technology, pattern, or solution was chosen?</p>"},{"location":"adr/0000-adr-template/#rationale","title":"Rationale","text":"<p>Explain the reasoning that led to this decision. Why was this particular option selected among the alternatives? Include relevant factors such as:</p> <ul> <li>Technical considerations</li> <li>Business requirements</li> <li>Team capabilities</li> <li>Time constraints</li> <li>Cost implications</li> </ul>"},{"location":"adr/0000-adr-template/#implications","title":"Implications","text":""},{"location":"adr/0000-adr-template/#positive-implications","title":"Positive Implications","text":"<p>List the benefits and positive outcomes expected from this decision.</p>"},{"location":"adr/0000-adr-template/#concerns","title":"Concerns","text":"<p>List potential challenges, risks, or negative consequences along with possible mitigation strategies.</p>"},{"location":"adr/0000-adr-template/#alternatives","title":"Alternatives","text":"<p>Describe other options that were considered and why they were not selected. For each alternative, briefly explain:</p> <ul> <li>Key characteristics</li> <li>Pros and cons relative to the chosen solution</li> <li>Reasons for rejection</li> </ul>"},{"location":"adr/0000-adr-template/#future-direction","title":"Future Direction","text":"<p>Outline any follow-up actions, future considerations, or potential changes that might be necessary as a result of this decision. Include potential triggers for revisiting this decision.</p>"},{"location":"adr/0000-adr-template/#references","title":"References","text":"<p>List any relevant documents, articles, books, or other resources that supported this decision:</p> <ul> <li>Links to relevant documentation</li> <li>Research materials</li> <li>Benchmarks or performance data</li> <li>Team discussions or meeting notes</li> </ul>"},{"location":"adr/0001-pydantic-for-data-models/","title":"ADR 0001: Use Pydantic v2 for Data Models","text":""},{"location":"adr/0001-pydantic-for-data-models/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0001-pydantic-for-data-models/#date","title":"Date","text":"<p>2026-01-05</p>"},{"location":"adr/0001-pydantic-for-data-models/#context","title":"Context","text":"<p>Interposition's data models (ResponseChunk, InteractionRequest, RequestFingerprint, Interaction, Cassette) are immutable structures representing recorded interactions. The library needs:</p> <ol> <li>Serialization: Save/load cassettes to/from JSON files for persistence</li> <li>Runtime Validation: Validate data when loading cassettes from external sources</li> <li>Immutability: Prevent accidental modification of recorded data</li> </ol>"},{"location":"adr/0001-pydantic-for-data-models/#decision","title":"Decision","text":"<p>Use Pydantic v2 <code>BaseModel</code> with <code>ConfigDict(frozen=True)</code> for all data models.</p> <p>Domain services (e.g., Broker) use regular Python classes since they don't require serialization.</p>"},{"location":"adr/0001-pydantic-for-data-models/#rationale","title":"Rationale","text":"<ul> <li>Built-in Serialization: <code>model_dump_json()</code> and <code>model_validate_json()</code> eliminate need for custom serialization code</li> <li>Automatic Validation: Validates data at construction and deserialization, catching malformed cassette files</li> <li>Immutability: <code>ConfigDict(frozen=True)</code> provides same guarantees as frozen dataclasses</li> <li>Type Safety: Excellent mypy strict mode support via pydantic.mypy plugin</li> <li>Performance: Rust core makes validation overhead negligible</li> <li>Clean Validation API: <code>@model_validator</code> for cross-field validation (e.g., fingerprint matching)</li> </ul>"},{"location":"adr/0001-pydantic-for-data-models/#implications","title":"Implications","text":""},{"location":"adr/0001-pydantic-for-data-models/#positive","title":"Positive","text":"<ul> <li>Cassette persistence without custom code</li> <li>Automatic validation catches corrupted files</li> <li>JSON schema generation for documentation</li> </ul>"},{"location":"adr/0001-pydantic-for-data-models/#concerns","title":"Concerns","text":"<ul> <li>External dependency adds ~6MB to installation size (mitigation: Pydantic is widely adopted and well-maintained, risk is low)</li> <li>Developers need to learn Pydantic patterns (mitigation: Pydantic is industry standard with excellent documentation)</li> </ul>"},{"location":"adr/0001-pydantic-for-data-models/#alternatives","title":"Alternatives","text":""},{"location":"adr/0001-pydantic-for-data-models/#stdlib-frozen-dataclasses","title":"Stdlib Frozen Dataclasses","text":"<p>Using <code>@dataclass(frozen=True, slots=True)</code> from Python's standard library.</p> <ul> <li>Pros: No external dependencies, familiar to Python developers, memory efficient</li> <li>Cons: No built-in serialization, no validation hooks, would require ~200+ lines of custom serialization code</li> <li>Reason for rejection: Serialization is a core requirement; implementing it manually adds significant complexity</li> </ul>"},{"location":"adr/0001-pydantic-for-data-models/#attrs-cattrs","title":"attrs + cattrs","text":"<p>Using attrs for data classes and cattrs for serialization.</p> <ul> <li>Pros: Mature library, supports validation, serialization via cattrs</li> <li>Cons: Less widely adopted than Pydantic, more complex configuration, no built-in schema generation</li> <li>Reason for rejection: Pydantic has better ecosystem integration and built-in schema generation</li> </ul>"},{"location":"adr/0001-pydantic-for-data-models/#named-tuples","title":"Named Tuples","text":"<p>Using <code>typing.NamedTuple</code> for immutable data structures.</p> <ul> <li>Pros: Built-in, immutable by default, lightweight</li> <li>Cons: Poor ergonomics for models with many fields, no validation hooks, limited extensibility</li> <li>Reason for rejection: Lack of validation support makes it unsuitable for external data validation</li> </ul>"},{"location":"adr/0001-pydantic-for-data-models/#custom-classes","title":"Custom Classes","text":"<p>Implementing custom classes with manual <code>__init__</code>, <code>__repr__</code>, <code>__eq__</code>, and serialization.</p> <ul> <li>Pros: Full control, no dependencies</li> <li>Cons: Significant boilerplate, error-prone, no serialization support, manual validation required</li> <li>Reason for rejection: Too much maintenance burden for functionality that Pydantic provides out-of-the-box</li> </ul>"},{"location":"adr/0001-pydantic-for-data-models/#future-direction","title":"Future Direction","text":"<p>Enables file-based cassette storage and schema generation for documentation.</p> <p>Revisit if Pydantic's dependency footprint or validation overhead becomes problematic.</p>"},{"location":"adr/0001-pydantic-for-data-models/#references","title":"References","text":"<ul> <li>Pydantic Documentation</li> <li>Pydantic Performance</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/","title":"ADR 0002: Use SHA-256 for Request Fingerprinting","text":""},{"location":"adr/0002-sha256-fingerprinting/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0002-sha256-fingerprinting/#date","title":"Date","text":"<p>2026-01-05</p>"},{"location":"adr/0002-sha256-fingerprinting/#context","title":"Context","text":"<p>The replay system needs to match incoming requests against recorded interactions. This requires a stable, deterministic fingerprinting mechanism that uniquely identifies requests based on their protocol, action, target, headers, and body content. The fingerprint must be consistent across different processes and Python sessions.</p>"},{"location":"adr/0002-sha256-fingerprinting/#decision","title":"Decision","text":"<p>Use SHA-256 hashing with canonical JSON serialization for request fingerprinting. The canonical representation is generated by serializing a list of request fields <code>[protocol, action, target, headers, body_hex]</code> using <code>json.dumps</code> with <code>separators=(\",\", \":\")</code> and <code>sort_keys=True</code> to ensure determinism and prevent delimiter collisions. Header ordering is preserved (no normalization).</p>"},{"location":"adr/0002-sha256-fingerprinting/#rationale","title":"Rationale","text":"<ul> <li>Stability: Hash-based fingerprints are deterministic and consistent across processes</li> <li>Collision resistance: SHA-256 combined with structure-preserving JSON serialization prevents accidental collisions (e.g., when fields contain the delimiter)</li> <li>Standard library: Available in Python's <code>hashlib</code> and <code>json</code> without external dependencies</li> <li>Canonical ordering: Fixed JSON separators ensure identical requests produce identical fingerprints regardless of environment without normalizing request data</li> <li>Binary-safe: Hex-encoded body in JSON handles arbitrary binary data safely</li> <li>Compact: Fixed-length 64-character hex digest is memory-efficient</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/#implications","title":"Implications","text":""},{"location":"adr/0002-sha256-fingerprinting/#positive-implications","title":"Positive Implications","text":"<ul> <li>Fingerprints are stable across application restarts and different machines</li> <li>O(1) lookup using fingerprints as dictionary keys</li> <li>No false positives from hash collisions in realistic scenarios</li> <li>Header order affects matching (no normalization)</li> <li>Works with any protocol (protocol-agnostic design)</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/#concerns","title":"Concerns","text":"<ul> <li>Hash computation has O(n) cost proportional to request size (mitigation: acceptable for typical request sizes)</li> <li>Changing canonical format breaks compatibility with existing cassettes (mitigation: version 0 is in-memory only)</li> <li>Cryptographic hashing may be overkill for this use case (mitigation: no measurable performance impact)</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/#alternatives","title":"Alternatives","text":""},{"location":"adr/0002-sha256-fingerprinting/#direct-request-comparison-__eq__","title":"Direct Request Comparison (<code>__eq__</code>)","text":"<p>Using direct object equality comparison to find matching requests.</p> <ul> <li>Pros: Simple implementation, no hashing overhead</li> <li>Cons: O(n) lookup time for finding interactions in cassette, cannot use requests as dictionary keys without stable hash</li> <li>Reason for rejection: Poor performance for large cassettes; O(n) lookup vs O(1) with hash-based index</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/#md5-hashing","title":"MD5 Hashing","text":"<p>Using MD5 hash algorithm for fingerprinting.</p> <ul> <li>Pros: Faster than SHA-256, sufficient for non-cryptographic use</li> <li>Cons: Considered cryptographically broken, community perception of MD5 weakness could undermine trust</li> <li>Reason for rejection: Reputational risk outweighs marginal performance gains</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/#non-cryptographic-hashes-xxhash-murmurhash","title":"Non-cryptographic Hashes (xxHash, MurmurHash)","text":"<p>Using fast non-cryptographic hash algorithms like xxHash or MurmurHash.</p> <ul> <li>Pros: Faster than SHA-256, designed for hash table use</li> <li>Cons: Requires external dependency, not in standard library, adds maintenance burden</li> <li>Reason for rejection: Performance difference is negligible for this use case; standard library preference</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/#tuple-based-keys","title":"Tuple-based Keys","text":"<p>Using tuples of request fields directly as dictionary keys.</p> <ul> <li>Pros: No hashing overhead, direct comparison</li> <li>Cons: Large memory footprint for storing full request data as keys</li> <li>Reason for rejection: Memory inefficient; stable hashing provides compact keys</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/#future-direction","title":"Future Direction","text":"<p>This decision should be revisited if:</p> <ul> <li>Performance profiling shows hashing is a bottleneck (consider faster non-cryptographic hashes)</li> <li>Large request bodies cause excessive memory pressure (consider streaming hash calculation without full in-memory loading)</li> <li>Cassette persistence is added and backward compatibility becomes critical (use versioning scheme)</li> <li>Protocol-specific fingerprinting is needed (extend with pluggable fingerprint strategies)</li> <li>Matching rules need to be customized (make fingerprinting + matching strategy injectable, including hash choice)</li> </ul>"},{"location":"adr/0002-sha256-fingerprinting/#references","title":"References","text":"<ul> <li>Python hashlib documentation</li> <li>SHA-256 specification</li> </ul>"},{"location":"adr/0003-generator-streaming/","title":"ADR 0003: Use Generator Pattern for Response Streaming","text":""},{"location":"adr/0003-generator-streaming/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0003-generator-streaming/#date","title":"Date","text":"<p>2026-01-05</p>"},{"location":"adr/0003-generator-streaming/#context","title":"Context","text":"<p>The replay system needs to deliver response chunks to consumers. Responses may consist of multiple chunks that should be delivered in sequence. The library must support both small responses (single chunk) and potentially large responses (many chunks) without excessive memory usage.</p>"},{"location":"adr/0003-generator-streaming/#decision","title":"Decision","text":"<p>Use Python generators (<code>Iterator[ResponseChunk]</code>) for streaming response chunks. The <code>Broker.replay()</code> method returns an iterator that yields chunks lazily.</p>"},{"location":"adr/0003-generator-streaming/#rationale","title":"Rationale","text":"<ul> <li>Memory efficiency: Chunks are yielded one at a time, avoiding loading entire response into memory</li> <li>Lazy evaluation: Consumers can process chunks as they arrive, enabling streaming workflows</li> <li>Pythonic: Generator pattern is idiomatic Python for sequential data</li> <li>Composable: Generators can be chained, filtered, or transformed using standard itertools</li> <li>Backpressure: Consumer controls iteration pace, natural flow control</li> <li>Testable: Easy to collect into list for testing (<code>list(broker.replay(request))</code>)</li> </ul>"},{"location":"adr/0003-generator-streaming/#implications","title":"Implications","text":""},{"location":"adr/0003-generator-streaming/#positive-implications","title":"Positive Implications","text":"<ul> <li>Scales to arbitrarily large responses without memory pressure</li> <li>Natural fit for streaming protocols (HTTP chunked encoding, gRPC streaming, etc.)</li> <li>Consumers can process chunks incrementally (progress indicators, real-time processing)</li> <li>Simple implementation using <code>yield from interaction.response_chunks</code></li> <li>Clear iteration boundary (StopIteration signals completion)</li> </ul>"},{"location":"adr/0003-generator-streaming/#concerns","title":"Concerns","text":"<ul> <li>Consumers must iterate to completion with no random access to middle chunks (mitigation: acceptable tradeoff for memory efficiency)</li> <li>Generator state cannot be reset for re-iteration (mitigation: call <code>replay()</code> again to get new generator)</li> <li>Error handling requires try/except around iteration, not just the initial call (mitigation: standard Python pattern for iterators)</li> <li>Some consumers may prefer materialized list (mitigation: use <code>list()</code> wrapper when needed)</li> </ul>"},{"location":"adr/0003-generator-streaming/#alternatives","title":"Alternatives","text":""},{"location":"adr/0003-generator-streaming/#return-tuple-of-chunks","title":"Return Tuple of Chunks","text":"<p>Returning all chunks as a tuple immediately.</p> <ul> <li>Pros: Simpler for consumers that need all chunks upfront, immutable collection</li> <li>Cons: Entire response must be loaded into memory before returning, no memory savings for large responses</li> <li>Reason for rejection: Defeats purpose of streaming; memory inefficient for large responses</li> </ul>"},{"location":"adr/0003-generator-streaming/#return-list-of-chunks","title":"Return List of Chunks","text":"<p>Returning all chunks as a list immediately.</p> <ul> <li>Pros: Familiar collection type, random access support</li> <li>Cons: Same memory concerns as tuple, mutable return type contradicts immutability principle</li> <li>Reason for rejection: Memory inefficiency plus mutability concerns</li> </ul>"},{"location":"adr/0003-generator-streaming/#async-generator-asynciteratorresponsechunk","title":"Async Generator (<code>AsyncIterator[ResponseChunk]</code>)","text":"<p>Using async generators for streaming chunks.</p> <ul> <li>Pros: Natural fit for I/O-bound operations, enables concurrent processing</li> <li>Cons: Adds complexity without clear benefit for in-memory replay, forces async/await on all consumers</li> <li>Reason for rejection: Unnecessary complexity for in-memory cassettes; consider for future I/O-based backends</li> </ul>"},{"location":"adr/0003-generator-streaming/#callback-based-api","title":"Callback-based API","text":"<p>Using callback functions to deliver chunks (e.g., <code>replay(request, on_chunk=callback)</code>).</p> <ul> <li>Pros: Familiar pattern from JavaScript, enables push-based flow</li> <li>Cons: Less Pythonic, harder to compose, inverted control flow is harder to test, no natural backpressure mechanism</li> <li>Reason for rejection: Generators provide better ergonomics and testability in Python</li> </ul>"},{"location":"adr/0003-generator-streaming/#future-direction","title":"Future Direction","text":"<p>This decision should be revisited if:</p> <ul> <li>Async I/O support is added (consider <code>AsyncIterator[ResponseChunk]</code>)</li> <li>Profiling shows generator overhead is measurable (unlikely)</li> <li>Random access to chunks is frequently needed (consider hybrid approach with optional materialization)</li> </ul>"},{"location":"adr/0003-generator-streaming/#references","title":"References","text":"<ul> <li>PEP 255 - Simple Generators</li> <li>Python Iterator Protocol</li> </ul>"},{"location":"adr/0004-first-match-strategy/","title":"ADR 0004: Use First-Match Strategy for Duplicate Interactions","text":""},{"location":"adr/0004-first-match-strategy/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0004-first-match-strategy/#date","title":"Date","text":"<p>2026-01-05</p>"},{"location":"adr/0004-first-match-strategy/#context","title":"Context","text":"<p>A cassette may contain multiple interactions with identical request fingerprints (same protocol, action, target, headers, and body) but different responses. This can occur when recording non-deterministic endpoints or capturing time-series data. The replay system must define which interaction to return when multiple matches exist.</p>"},{"location":"adr/0004-first-match-strategy/#decision","title":"Decision","text":"<p>Always return the first matching interaction when multiple interactions share the same fingerprint. Subsequent matches are ignored during replay.</p>"},{"location":"adr/0004-first-match-strategy/#rationale","title":"Rationale","text":"<ul> <li>Determinism: First-match guarantees consistent behavior across replay sessions</li> <li>Simplicity: No complex selection logic or state tracking required</li> <li>Testability: Easy to verify behavior with duplicate interactions</li> <li>Predictability: Insertion order (recording order) determines replay order</li> <li>O(1) performance: First-match enables simple index-based lookup (see ADR 0005)</li> <li>Clear semantics: \"First recorded, first replayed\" is intuitive</li> </ul>"},{"location":"adr/0004-first-match-strategy/#implications","title":"Implications","text":""},{"location":"adr/0004-first-match-strategy/#positive-implications","title":"Positive Implications","text":"<ul> <li>Deterministic replay behavior simplifies debugging</li> <li>Implementation is trivial (index stores first occurrence)</li> <li>No need for match counters or stateful replay logic</li> <li>Clear contract: cassette creation order matters</li> <li>Works naturally with append-only recording workflows</li> </ul>"},{"location":"adr/0004-first-match-strategy/#concerns","title":"Concerns","text":"<ul> <li>Subsequent duplicate interactions are silently ignored (mitigation: intentional design for simplicity; users can filter cassettes if needed)</li> <li>No built-in support for stateful replay sequences (mitigation: can be layered on top with StatefulBroker wrapper in future)</li> <li>Users cannot specify which duplicate to use without cassette manipulation (mitigation: cassette ordering is under user control)</li> <li>Order dependency may surprise users expecting round-robin or random selection (mitigation: documented behavior; first-match is intuitive)</li> </ul>"},{"location":"adr/0004-first-match-strategy/#alternatives","title":"Alternatives","text":""},{"location":"adr/0004-first-match-strategy/#all-match-return-iterator-of-all-matches","title":"All-Match (Return Iterator of All Matches)","text":"<p>Returning an iterator of all matching interactions instead of a single match.</p> <ul> <li>Pros: Preserves all recorded data</li> <li>Cons: Unclear which response to use for a single replay, forces complexity onto consumers</li> <li>Reason for rejection: Does not solve the fundamental question of which response to use; pushes decision-making burden onto every consumer</li> </ul>"},{"location":"adr/0004-first-match-strategy/#round-robin-strategy","title":"Round-Robin Strategy","text":"<p>Cycling through matching interactions on successive calls.</p> <ul> <li>Pros: Could model stateful interactions</li> <li>Cons: Requires mutable state in Broker (violates immutability principle), non-deterministic across different broker instances</li> <li>Reason for rejection: Breaks immutability guarantees and makes replay behavior unpredictable when using multiple broker instances</li> </ul>"},{"location":"adr/0004-first-match-strategy/#random-selection","title":"Random Selection","text":"<p>Randomly selecting one of the matching interactions.</p> <ul> <li>Pros: Simple to implement</li> <li>Cons: Non-deterministic makes testing harder, no clear use case for this behavior, violates principle of predictable replay</li> <li>Reason for rejection: Non-determinism is fundamentally incompatible with the goal of reproducible test fixtures</li> </ul>"},{"location":"adr/0004-first-match-strategy/#raise-error-on-duplicates","title":"Raise Error on Duplicates","text":"<p>Throwing an error when duplicate fingerprints are detected in a cassette.</p> <ul> <li>Pros: Makes order dependency explicit</li> <li>Cons: Too strict, prevents legitimate recording scenarios, forces users to deduplicate cassettes manually</li> <li>Reason for rejection: Overly restrictive; duplicates are legitimate in real-world recording (non-deterministic endpoints, time-series data)</li> </ul>"},{"location":"adr/0004-first-match-strategy/#last-match-strategy","title":"Last-Match Strategy","text":"<p>Returning the last matching interaction instead of the first.</p> <ul> <li>Pros: Simple to implement</li> <li>Cons: Counter-intuitive (why record earlier interactions if they're ignored?), no advantage over first-match</li> <li>Reason for rejection: No meaningful benefit over first-match while being less intuitive about why earlier recordings exist</li> </ul>"},{"location":"adr/0004-first-match-strategy/#future-direction","title":"Future Direction","text":"<p>This decision should be revisited if:</p> <ul> <li>Stateful replay (consuming interactions on use) is needed (add explicit mode or new Broker type)</li> <li>Users frequently need round-robin behavior (consider StatefulBroker wrapper)</li> <li>Duplicate detection is required (add validation utility, not core behavior)</li> <li>Complex matching strategies are needed (introduce pluggable strategy pattern)</li> <li>Matching strategy becomes pluggable (keep first-match as the default when duplicates occur)</li> </ul> <p>Use first-match as the foundation. More complex strategies can be layered on top without changing the core behavior.</p>"},{"location":"adr/0004-first-match-strategy/#references","title":"References","text":"<ul> <li>VCR.rb uses first-match by default for duplicate cassettes</li> <li>WireMock uses priority-based matching (more complex, rejected for v0)</li> </ul>"},{"location":"adr/0005-cassette-index/","title":"ADR 0005: Build Fingerprint Index for O(1) Lookup","text":""},{"location":"adr/0005-cassette-index/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0005-cassette-index/#date","title":"Date","text":"<p>2026-01-05</p>"},{"location":"adr/0005-cassette-index/#context","title":"Context","text":"<p>The cassette stores interactions as a tuple and needs to find interactions matching a given request fingerprint. Without an index, finding a match requires linear search (O(n)) through all interactions. For large cassettes with hundreds or thousands of interactions, this becomes a performance bottleneck.</p>"},{"location":"adr/0005-cassette-index/#decision","title":"Decision","text":"<p>Build a <code>dict[RequestFingerprint, int]</code> index at cassette construction that maps fingerprints to their first occurrence position in the interactions tuple. The index is built using a model validator and stored as a private attribute.</p>"},{"location":"adr/0005-cassette-index/#rationale","title":"Rationale","text":"<ul> <li>O(1) lookup: Dictionary lookup is constant time, vastly superior to O(n) linear search</li> <li>Initialization cost: Index is built once during cassette creation, amortized over many lookups</li> <li>Memory efficiency: Index stores only integers (positions), not duplicate interaction data</li> <li>First-match alignment: Index naturally stores first occurrence, implementing ADR 0004</li> <li>Immutable after creation: Index is built during construction and never modified</li> <li>Transparent: Implementation detail hidden from users (private attribute)</li> </ul>"},{"location":"adr/0005-cassette-index/#implications","title":"Implications","text":""},{"location":"adr/0005-cassette-index/#positive-implications","title":"Positive Implications","text":"<ul> <li>Replay performance is independent of cassette size (O(1) vs O(n))</li> <li>Enables large cassettes (thousands of interactions) without performance degradation</li> <li>Simple implementation using standard library dict</li> <li>Index construction is deterministic and testable</li> <li>Memory overhead is minimal (one int per unique fingerprint)</li> </ul>"},{"location":"adr/0005-cassette-index/#concerns","title":"Concerns","text":"<ul> <li>Upfront cost to build index during cassette creation (mitigation: acceptable one-time cost amortized over many lookups)</li> <li>Uses <code>object.__setattr__</code> to mutate frozen model (mitigation: required for immutability, Pydantic pattern for private attributes)</li> <li>Memory overhead for the index dict (mitigation: minimal, ~8 bytes per unique fingerprint)</li> <li>Index is not exposed in serialization or repr (mitigation: intentional design, private implementation detail)</li> </ul>"},{"location":"adr/0005-cassette-index/#alternatives","title":"Alternatives","text":""},{"location":"adr/0005-cassette-index/#linear-search-no-index","title":"Linear Search (No Index)","text":"<p>Finding interactions by iterating through the tuple without an index.</p> <ul> <li>Pros: No memory overhead, simpler implementation</li> <li>Cons: O(n) lookup time becomes bottleneck for large cassettes, performance degrades proportionally with cassette size</li> <li>Reason for rejection: Performance is unacceptable for production use with large cassettes (hundreds or thousands of interactions)</li> </ul>"},{"location":"adr/0005-cassette-index/#build-index-on-first-lookup-lazy-initialization","title":"Build Index on First Lookup (Lazy Initialization)","text":"<p>Deferring index construction until the first lookup call.</p> <ul> <li>Pros: Defers cost if cassette is never used</li> <li>Cons: Requires mutable state to track \"index built\" flag, violates frozen model immutability principle</li> <li>Reason for rejection: Breaks immutability guarantees; construction-time indexing is simpler and aligns with frozen model design</li> </ul>"},{"location":"adr/0005-cassette-index/#external-index-separate-data-structure","title":"External Index (Separate Data Structure)","text":"<p>Maintaining the index as a separate object outside the cassette.</p> <ul> <li>Pros: Clear separation of concerns</li> <li>Cons: Requires managing two objects (cassette + index) in sync, more complex API (users must pass both), risk of desynchronization if index is mutated</li> <li>Reason for rejection: API complexity and synchronization risk outweigh benefits; internal index is simpler and safer</li> </ul>"},{"location":"adr/0005-cassette-index/#use-list-instead-of-tuple-for-interactions","title":"Use List Instead of Tuple for Interactions","text":"<p>Storing interactions in a mutable list to enable direct mutation.</p> <ul> <li>Pros: No workaround needed for frozen models</li> <li>Cons: Mutable collection contradicts immutability principle, no advantage for index-based access (tuple supports indexing)</li> <li>Reason for rejection: Immutability is a core design principle; tuple is the correct choice for frozen data</li> </ul>"},{"location":"adr/0005-cassette-index/#store-interactions-in-dict-no-tuple","title":"Store Interactions in Dict (No Tuple)","text":"<p>Using a dict mapping fingerprints to interactions directly, eliminating the tuple.</p> <ul> <li>Pros: Built-in O(1) lookup without separate index</li> <li>Cons: Loses insertion order for duplicates (violates ADR 0004), cannot represent multiple interactions with same fingerprint, fundamentally different data model</li> <li>Reason for rejection: Incompatible with first-match strategy; duplicates are legitimate and must be preserved in order</li> </ul>"},{"location":"adr/0005-cassette-index/#future-direction","title":"Future Direction","text":"<p>This decision should be revisited if:</p> <ul> <li>Profiling shows index build time is a bottleneck (unlikely, dict insert is fast)</li> <li>Memory pressure from large indexes becomes an issue (consider specialized data structures)</li> <li>Alternative frozen dataclass patterns emerge (Python 3.13+ features)</li> <li>Cassette persistence requires serializing/deserializing the index (versioning strategy needed)</li> <li>Matching strategy becomes pluggable (index should be built from the configured fingerprinting strategy)</li> </ul>"},{"location":"adr/0005-cassette-index/#references","title":"References","text":"<ul> <li>Python dict implementation</li> <li>Dataclass frozen=True documentation</li> <li>Big-O Complexity of Python Operations</li> </ul>"},{"location":"adr/0006-external-adapters/","title":"ADR 0006: External Protocol Adapters Strategy","text":""},{"location":"adr/0006-external-adapters/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0006-external-adapters/#date","title":"Date","text":"<p>2026-01-10</p>"},{"location":"adr/0006-external-adapters/#context","title":"Context","text":"<p>Interposition is designed to be a protocol-agnostic logic engine for recording and replaying interactions.</p> <p>Users integrate Interposition with various consumers. These include:</p> <ul> <li>Python libraries: e.g., <code>requests</code>, <code>psycopg2</code>, <code>boto3</code>.</li> <li>External processes: e.g., <code>curl</code> commands, <code>psql</code> clients, or applications written in other languages (Node.js, Go).</li> </ul> <p>A key architectural decision is whether to include specific adapters for these use cases within the core <code>interposition</code> package or to keep them separate.</p>"},{"location":"adr/0006-external-adapters/#decision","title":"Decision","text":"<p>We will NOT include protocol-specific adapters in the core <code>interposition</code> package.</p> <p>Adapters must be:</p> <ol> <li>Implemented by the user or provided as separate packages.</li> <li>Capable of using the strategy best suited for the target (e.g., Monkey Patching for simple Python unit tests, Proxy Servers for black-box E2E tests).</li> </ol> <p>The core package will remain a pure logic engine with minimal dependencies.</p>"},{"location":"adr/0006-external-adapters/#rationale","title":"Rationale","text":"<ul> <li>Diverse Integration Strategies: Different contexts require different integration methods. A unit test might prefer a lightweight monkey patch on <code>requests</code>, while an E2E test requires a transparent HTTP proxy to intercept traffic from a subprocess. The core engine should not dictate the integration strategy.</li> <li>Separation of Concerns: Interposition handles what to replay. The Adapter handles how to intercept it.</li> <li>Dependency Management: Including adapters for every possible library and protocol would bloat the core package.</li> <li>Release Independence: The core engine should not need updates when external libraries change.</li> </ul>"},{"location":"adr/0006-external-adapters/#implications","title":"Implications","text":""},{"location":"adr/0006-external-adapters/#positive-implications","title":"Positive Implications","text":"<ul> <li>Flexibility: Users can choose to implement a Proxy, a Monkey Patch, or a Decorator based on their testing needs.</li> <li>Lightweight Core: <code>pip install interposition</code> remains small and fast.</li> <li>E2E Support: Explicitly designing for \"external adapters\" encourages the creation of proxy-based tools that enable language-agnostic testing.</li> </ul>"},{"location":"adr/0006-external-adapters/#concerns","title":"Concerns","text":"<ul> <li>Onboarding Friction: Users need to write glue code to get started (Mitigation: Provide high-quality \"Reference Implementations\" in <code>examples/</code> for both strategies, e.g., a <code>requests</code> patcher AND a simple HTTP proxy).</li> </ul>"},{"location":"adr/0006-external-adapters/#alternatives","title":"Alternatives","text":""},{"location":"adr/0006-external-adapters/#include-common-adapters-eg-requests-in-core","title":"Include Common Adapters (e.g., <code>requests</code>) in Core","text":"<p>Include adapters for the most popular libraries (like <code>requests</code>) in the main package.</p> <ul> <li>Pros: Easier onboarding for the majority of users.</li> <li>Cons: Increases maintenance burden and dependency graph.</li> <li>Reason for Rejection: Violates the strict separation of concerns.</li> </ul>"},{"location":"adr/0006-external-adapters/#monorepo-with-multiple-packages","title":"Monorepo with Multiple Packages","text":"<p>Manage core and adapters in a single monorepo but publish them as separate PyPI packages (<code>interposition</code>, <code>interposition-requests</code>, etc.).</p> <ul> <li>Pros: Centralized management, separate dependencies.</li> <li>Cons: Higher complexity in CI/CD and release processes.</li> <li>Reason for Rejection: Premature complexity. We will start with Reference Implementations and consider separate packages if demand grows.</li> </ul>"},{"location":"adr/0006-external-adapters/#future-direction","title":"Future Direction","text":"<p>We will create an <code>examples/</code> directory to house high-quality reference adapters. If a specific adapter becomes extremely popular and stable, we may consider adopting it as an official separate package (e.g., <code>interposition-requests</code>) under the same organization, but it will remain distinct from the core.</p>"},{"location":"adr/0006-external-adapters/#references","title":"References","text":"<ul> <li>OpenTelemetry Architecture (Separation of API/SDK from Instrumentation)</li> </ul>"},{"location":"api/api_reference/","title":"API Reference","text":"<p>This page documents the public API of the interposition library.</p>"},{"location":"api/api_reference/#core-module","title":"Core Module","text":""},{"location":"api/api_reference/#interposition","title":"interposition","text":"<p>Protocol-agnostic interaction interposition with lifecycle hooks.</p> <p>Provides record, replay, and control capabilities.</p>"},{"location":"api/api_reference/#interposition.Broker","title":"Broker","text":"<p>Manages interaction replay from cassettes.</p> <p>Attributes:</p> Name Type Description <code>cassette</code> <code>Cassette</code> <p>The cassette containing recorded interactions</p> Source code in <code>src/interposition/services.py</code> <pre><code>class Broker:\n    \"\"\"Manages interaction replay from cassettes.\n\n    Attributes:\n        cassette: The cassette containing recorded interactions\n    \"\"\"\n\n    def __init__(self, cassette: Cassette) -&gt; None:\n        \"\"\"Initialize broker with a cassette.\n\n        Args:\n            cassette: The cassette containing recorded interactions\n        \"\"\"\n        self._cassette = cassette\n\n    @property\n    def cassette(self) -&gt; Cassette:\n        \"\"\"Get the cassette.\"\"\"\n        return self._cassette\n\n    def replay(self, request: InteractionRequest) -&gt; Iterator[ResponseChunk]:\n        \"\"\"Replay recorded response for matching request.\n\n        Args:\n            request: The request to match and replay\n\n        Yields:\n            ResponseChunks in original recorded order\n\n        Raises:\n            InteractionNotFoundError: When no matching interaction exists\n        \"\"\"\n        fingerprint = request.fingerprint()\n        interaction = self.cassette.find_interaction(fingerprint)\n\n        if interaction is None:\n            raise InteractionNotFoundError(request)\n\n        yield from interaction.response_chunks\n</code></pre>"},{"location":"api/api_reference/#interposition.Broker.cassette","title":"cassette  <code>property</code>","text":"<pre><code>cassette: Cassette\n</code></pre> <p>Get the cassette.</p>"},{"location":"api/api_reference/#interposition.Broker.__init__","title":"__init__","text":"<pre><code>__init__(cassette: Cassette) -&gt; None\n</code></pre> <p>Initialize broker with a cassette.</p> <p>Parameters:</p> Name Type Description Default <code>cassette</code> <code>Cassette</code> <p>The cassette containing recorded interactions</p> required Source code in <code>src/interposition/services.py</code> <pre><code>def __init__(self, cassette: Cassette) -&gt; None:\n    \"\"\"Initialize broker with a cassette.\n\n    Args:\n        cassette: The cassette containing recorded interactions\n    \"\"\"\n    self._cassette = cassette\n</code></pre>"},{"location":"api/api_reference/#interposition.Broker.replay","title":"replay","text":"<pre><code>replay(\n    request: InteractionRequest,\n) -&gt; Iterator[ResponseChunk]\n</code></pre> <p>Replay recorded response for matching request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>InteractionRequest</code> <p>The request to match and replay</p> required <p>Yields:</p> Type Description <code>ResponseChunk</code> <p>ResponseChunks in original recorded order</p> <p>Raises:</p> Type Description <code>InteractionNotFoundError</code> <p>When no matching interaction exists</p> Source code in <code>src/interposition/services.py</code> <pre><code>def replay(self, request: InteractionRequest) -&gt; Iterator[ResponseChunk]:\n    \"\"\"Replay recorded response for matching request.\n\n    Args:\n        request: The request to match and replay\n\n    Yields:\n        ResponseChunks in original recorded order\n\n    Raises:\n        InteractionNotFoundError: When no matching interaction exists\n    \"\"\"\n    fingerprint = request.fingerprint()\n    interaction = self.cassette.find_interaction(fingerprint)\n\n    if interaction is None:\n        raise InteractionNotFoundError(request)\n\n    yield from interaction.response_chunks\n</code></pre>"},{"location":"api/api_reference/#interposition.Cassette","title":"Cassette","text":"<p>               Bases: <code>BaseModel</code></p> <p>In-memory collection of recorded interactions.</p> <p>Attributes:</p> Name Type Description <code>interactions</code> <code>tuple[Interaction, ...]</code> <p>Ordered sequence of interactions</p> Source code in <code>src/interposition/models.py</code> <pre><code>class Cassette(BaseModel):\n    \"\"\"In-memory collection of recorded interactions.\n\n    Attributes:\n        interactions: Ordered sequence of interactions\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    interactions: tuple[Interaction, ...]\n    _index: dict[RequestFingerprint, int] = PrivateAttr(default_factory=dict)\n\n    @model_validator(mode=\"after\")\n    def build_index(self) -&gt; Self:\n        \"\"\"Build fingerprint index for efficient lookup.\"\"\"\n        index: dict[RequestFingerprint, int] = {}\n        for i, interaction in enumerate(self.interactions):\n            # Only store first occurrence of each fingerprint\n            if interaction.fingerprint not in index:\n                index[interaction.fingerprint] = i\n        # Use object.__setattr__ to modify frozen model\n        object.__setattr__(self, \"_index\", index)\n        return self\n\n    def find_interaction(self, fingerprint: RequestFingerprint) -&gt; Interaction | None:\n        \"\"\"Find first interaction matching fingerprint.\n\n        Args:\n            fingerprint: Request fingerprint to search for\n\n        Returns:\n            Matching Interaction or None if not found\n        \"\"\"\n        position = self._index.get(fingerprint)\n        if position is None:\n            return None\n        return self.interactions[position]\n</code></pre>"},{"location":"api/api_reference/#interposition.Cassette.build_index","title":"build_index","text":"<pre><code>build_index() -&gt; Self\n</code></pre> <p>Build fingerprint index for efficient lookup.</p> Source code in <code>src/interposition/models.py</code> <pre><code>@model_validator(mode=\"after\")\ndef build_index(self) -&gt; Self:\n    \"\"\"Build fingerprint index for efficient lookup.\"\"\"\n    index: dict[RequestFingerprint, int] = {}\n    for i, interaction in enumerate(self.interactions):\n        # Only store first occurrence of each fingerprint\n        if interaction.fingerprint not in index:\n            index[interaction.fingerprint] = i\n    # Use object.__setattr__ to modify frozen model\n    object.__setattr__(self, \"_index\", index)\n    return self\n</code></pre>"},{"location":"api/api_reference/#interposition.Cassette.find_interaction","title":"find_interaction","text":"<pre><code>find_interaction(\n    fingerprint: RequestFingerprint,\n) -&gt; Interaction | None\n</code></pre> <p>Find first interaction matching fingerprint.</p> <p>Parameters:</p> Name Type Description Default <code>fingerprint</code> <code>RequestFingerprint</code> <p>Request fingerprint to search for</p> required <p>Returns:</p> Type Description <code>Interaction | None</code> <p>Matching Interaction or None if not found</p> Source code in <code>src/interposition/models.py</code> <pre><code>def find_interaction(self, fingerprint: RequestFingerprint) -&gt; Interaction | None:\n    \"\"\"Find first interaction matching fingerprint.\n\n    Args:\n        fingerprint: Request fingerprint to search for\n\n    Returns:\n        Matching Interaction or None if not found\n    \"\"\"\n    position = self._index.get(fingerprint)\n    if position is None:\n        return None\n    return self.interactions[position]\n</code></pre>"},{"location":"api/api_reference/#interposition.Interaction","title":"Interaction","text":"<p>               Bases: <code>BaseModel</code></p> <p>Complete request-response pair for replay.</p> <p>Attributes:</p> Name Type Description <code>request</code> <code>InteractionRequest</code> <p>The original InteractionRequest</p> <code>fingerprint</code> <code>RequestFingerprint</code> <p>Precomputed request fingerprint for matching</p> <code>response_chunks</code> <code>tuple[ResponseChunk, ...]</code> <p>Ordered sequence of response chunks</p> <code>metadata</code> <code>tuple[tuple[str, str], ...]</code> <p>Optional interaction metadata as (key, value) pairs. Examples: recording timestamp, session ID, test scenario name. Useful for debugging and tracing recorded interactions. Default is empty tuple.</p> Source code in <code>src/interposition/models.py</code> <pre><code>class Interaction(BaseModel):\n    \"\"\"Complete request-response pair for replay.\n\n    Attributes:\n        request: The original InteractionRequest\n        fingerprint: Precomputed request fingerprint for matching\n        response_chunks: Ordered sequence of response chunks\n        metadata: Optional interaction metadata as (key, value) pairs.\n            Examples: recording timestamp, session ID, test scenario name.\n            Useful for debugging and tracing recorded interactions.\n            Default is empty tuple.\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    request: InteractionRequest\n    fingerprint: RequestFingerprint\n    response_chunks: tuple[ResponseChunk, ...]\n    metadata: tuple[tuple[str, str], ...] = ()\n\n    @model_validator(mode=\"after\")\n    def validate_interaction(self) -&gt; Self:\n        \"\"\"Validate interaction integrity.\n\n        Raises:\n            InteractionValidationError: If fingerprint doesn't match request\n                or chunks aren't sequential\n        \"\"\"\n        # Verify fingerprint matches request\n        expected_fingerprint = self.request.fingerprint()\n        if self.fingerprint != expected_fingerprint:\n            msg = (\n                f\"Fingerprint does not match request: \"\n                f\"expected {expected_fingerprint.value}, got {self.fingerprint.value}\"\n            )\n            raise InteractionValidationError(msg)\n\n        # Verify response chunks are sequentially ordered\n        if not self.response_chunks:\n            msg = \"Response chunks cannot be empty\"\n            raise InteractionValidationError(msg)\n\n        if self.response_chunks[0].sequence != 0:\n            msg = \"Response chunks must start at sequence 0\"\n            raise InteractionValidationError(msg)\n\n        for i, chunk in enumerate(self.response_chunks):\n            if chunk.sequence != i:\n                msg = \"Response chunks must be sequential with no gaps\"\n                raise InteractionValidationError(msg)\n\n        return self\n</code></pre>"},{"location":"api/api_reference/#interposition.Interaction.validate_interaction","title":"validate_interaction","text":"<pre><code>validate_interaction() -&gt; Self\n</code></pre> <p>Validate interaction integrity.</p> <p>Raises:</p> Type Description <code>InteractionValidationError</code> <p>If fingerprint doesn't match request or chunks aren't sequential</p> Source code in <code>src/interposition/models.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_interaction(self) -&gt; Self:\n    \"\"\"Validate interaction integrity.\n\n    Raises:\n        InteractionValidationError: If fingerprint doesn't match request\n            or chunks aren't sequential\n    \"\"\"\n    # Verify fingerprint matches request\n    expected_fingerprint = self.request.fingerprint()\n    if self.fingerprint != expected_fingerprint:\n        msg = (\n            f\"Fingerprint does not match request: \"\n            f\"expected {expected_fingerprint.value}, got {self.fingerprint.value}\"\n        )\n        raise InteractionValidationError(msg)\n\n    # Verify response chunks are sequentially ordered\n    if not self.response_chunks:\n        msg = \"Response chunks cannot be empty\"\n        raise InteractionValidationError(msg)\n\n    if self.response_chunks[0].sequence != 0:\n        msg = \"Response chunks must start at sequence 0\"\n        raise InteractionValidationError(msg)\n\n    for i, chunk in enumerate(self.response_chunks):\n        if chunk.sequence != i:\n            msg = \"Response chunks must be sequential with no gaps\"\n            raise InteractionValidationError(msg)\n\n    return self\n</code></pre>"},{"location":"api/api_reference/#interposition.InteractionRequest","title":"InteractionRequest","text":"<p>               Bases: <code>BaseModel</code></p> <p>Structured representation of a protocol-agnostic request.</p> <p>Attributes:</p> Name Type Description <code>protocol</code> <code>str</code> <p>Protocol identifier (e.g., \"grpc\", \"graphql\", \"mqtt\")</p> <code>action</code> <code>str</code> <p>Action/method name (e.g., \"ListUsers\", \"query\", \"publish\")</p> <code>target</code> <code>str</code> <p>Target resource (e.g., \"users.UserService\", \"topic/sensors\")</p> <code>headers</code> <code>tuple[tuple[str, str], ...]</code> <p>Request headers as immutable sequence of key-value pairs</p> <code>body</code> <code>bytes</code> <p>Request body content as bytes</p> Source code in <code>src/interposition/models.py</code> <pre><code>class InteractionRequest(BaseModel):\n    \"\"\"Structured representation of a protocol-agnostic request.\n\n    Attributes:\n        protocol: Protocol identifier (e.g., \"grpc\", \"graphql\", \"mqtt\")\n        action: Action/method name (e.g., \"ListUsers\", \"query\", \"publish\")\n        target: Target resource (e.g., \"users.UserService\", \"topic/sensors\")\n        headers: Request headers as immutable sequence of key-value pairs\n        body: Request body content as bytes\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    protocol: str\n    action: str\n    target: str\n    headers: tuple[tuple[str, str], ...]\n    body: bytes\n\n    def fingerprint(self) -&gt; RequestFingerprint:\n        \"\"\"Generate stable fingerprint for efficient matching.\n\n        Returns:\n            RequestFingerprint derived from all request fields.\n        \"\"\"\n        return RequestFingerprint.from_request(self)\n</code></pre>"},{"location":"api/api_reference/#interposition.InteractionRequest.fingerprint","title":"fingerprint","text":"<pre><code>fingerprint() -&gt; RequestFingerprint\n</code></pre> <p>Generate stable fingerprint for efficient matching.</p> <p>Returns:</p> Type Description <code>RequestFingerprint</code> <p>RequestFingerprint derived from all request fields.</p> Source code in <code>src/interposition/models.py</code> <pre><code>def fingerprint(self) -&gt; RequestFingerprint:\n    \"\"\"Generate stable fingerprint for efficient matching.\n\n    Returns:\n        RequestFingerprint derived from all request fields.\n    \"\"\"\n    return RequestFingerprint.from_request(self)\n</code></pre>"},{"location":"api/api_reference/#interposition.ResponseChunk","title":"ResponseChunk","text":"<p>               Bases: <code>BaseModel</code></p> <p>Discrete piece of response data.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>bytes</code> <p>Chunk payload as bytes</p> <code>sequence</code> <code>int</code> <p>Zero-based chunk position in response stream</p> <code>metadata</code> <code>tuple[tuple[str, str], ...]</code> <p>Optional chunk metadata as (key, value) string pairs. Examples: timing info, encoding, content-type for this chunk. Default is empty tuple.</p> Source code in <code>src/interposition/models.py</code> <pre><code>class ResponseChunk(BaseModel):\n    \"\"\"Discrete piece of response data.\n\n    Attributes:\n        data: Chunk payload as bytes\n        sequence: Zero-based chunk position in response stream\n        metadata: Optional chunk metadata as (key, value) string pairs.\n            Examples: timing info, encoding, content-type for this chunk.\n            Default is empty tuple.\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    data: bytes\n    sequence: int\n    metadata: tuple[tuple[str, str], ...] = ()\n</code></pre>"},{"location":"api/api_reference/#interposition.RequestFingerprint","title":"RequestFingerprint","text":"<p>               Bases: <code>BaseModel</code></p> <p>Stable unique identifier for request matching.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>str</code> <p>SHA-256 hash of canonicalized request fields</p> Source code in <code>src/interposition/models.py</code> <pre><code>class RequestFingerprint(BaseModel):\n    \"\"\"Stable unique identifier for request matching.\n\n    Attributes:\n        value: SHA-256 hash of canonicalized request fields\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    value: str\n\n    @field_validator(\"value\")\n    @classmethod\n    def validate_sha256_hex(cls, v: str) -&gt; str:\n        \"\"\"Validate that value is a valid SHA-256 hex string.\n\n        Args:\n            v: The fingerprint value to validate\n\n        Returns:\n            The validated value\n\n        Raises:\n            ValueError: If value is not exactly 64 hex characters\n        \"\"\"\n        if len(v) != SHA256_HEX_LENGTH:\n            msg = f\"SHA-256 hex must be exactly {SHA256_HEX_LENGTH} characters\"\n            raise ValueError(msg)\n        if not all(c in \"0123456789abcdef\" for c in v):\n            msg = \"Invalid hex characters in fingerprint\"\n            raise ValueError(msg)\n        return v\n\n    @classmethod\n    def from_request(cls, request: InteractionRequest) -&gt; Self:\n        \"\"\"Create fingerprint from InteractionRequest.\n\n        Args:\n            request: The request to fingerprint\n\n        Returns:\n            RequestFingerprint with SHA-256 hash value\n        \"\"\"\n        # Canonical order: protocol, action, target, headers, body\n        # Preserve header ordering to avoid normalization.\n        canonical_data = [\n            request.protocol,\n            request.action,\n            request.target,\n            request.headers,\n            request.body.hex(),\n        ]\n        canonical = json.dumps(\n            canonical_data,\n            separators=_CANONICAL_JSON_SEPARATORS,\n            sort_keys=_CANONICAL_JSON_SORT_KEYS,\n        )\n        hash_value = hashlib.sha256(canonical.encode(\"utf-8\")).hexdigest()\n        return cls(value=hash_value)\n</code></pre>"},{"location":"api/api_reference/#interposition.RequestFingerprint.validate_sha256_hex","title":"validate_sha256_hex  <code>classmethod</code>","text":"<pre><code>validate_sha256_hex(v: str) -&gt; str\n</code></pre> <p>Validate that value is a valid SHA-256 hex string.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>The fingerprint value to validate</p> required <p>Returns:</p> Type Description <code>str</code> <p>The validated value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If value is not exactly 64 hex characters</p> Source code in <code>src/interposition/models.py</code> <pre><code>@field_validator(\"value\")\n@classmethod\ndef validate_sha256_hex(cls, v: str) -&gt; str:\n    \"\"\"Validate that value is a valid SHA-256 hex string.\n\n    Args:\n        v: The fingerprint value to validate\n\n    Returns:\n        The validated value\n\n    Raises:\n        ValueError: If value is not exactly 64 hex characters\n    \"\"\"\n    if len(v) != SHA256_HEX_LENGTH:\n        msg = f\"SHA-256 hex must be exactly {SHA256_HEX_LENGTH} characters\"\n        raise ValueError(msg)\n    if not all(c in \"0123456789abcdef\" for c in v):\n        msg = \"Invalid hex characters in fingerprint\"\n        raise ValueError(msg)\n    return v\n</code></pre>"},{"location":"api/api_reference/#interposition.RequestFingerprint.from_request","title":"from_request  <code>classmethod</code>","text":"<pre><code>from_request(request: InteractionRequest) -&gt; Self\n</code></pre> <p>Create fingerprint from InteractionRequest.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>InteractionRequest</code> <p>The request to fingerprint</p> required <p>Returns:</p> Type Description <code>Self</code> <p>RequestFingerprint with SHA-256 hash value</p> Source code in <code>src/interposition/models.py</code> <pre><code>@classmethod\ndef from_request(cls, request: InteractionRequest) -&gt; Self:\n    \"\"\"Create fingerprint from InteractionRequest.\n\n    Args:\n        request: The request to fingerprint\n\n    Returns:\n        RequestFingerprint with SHA-256 hash value\n    \"\"\"\n    # Canonical order: protocol, action, target, headers, body\n    # Preserve header ordering to avoid normalization.\n    canonical_data = [\n        request.protocol,\n        request.action,\n        request.target,\n        request.headers,\n        request.body.hex(),\n    ]\n    canonical = json.dumps(\n        canonical_data,\n        separators=_CANONICAL_JSON_SEPARATORS,\n        sort_keys=_CANONICAL_JSON_SORT_KEYS,\n    )\n    hash_value = hashlib.sha256(canonical.encode(\"utf-8\")).hexdigest()\n    return cls(value=hash_value)\n</code></pre>"},{"location":"api/api_reference/#interposition.InteractionNotFoundError","title":"InteractionNotFoundError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when no matching interaction is found in cassette.</p> Source code in <code>src/interposition/errors.py</code> <pre><code>class InteractionNotFoundError(Exception):\n    \"\"\"Raised when no matching interaction is found in cassette.\"\"\"\n\n    def __init__(self, request: InteractionRequest) -&gt; None:\n        \"\"\"Initialize with request that failed to match.\n\n        Args:\n            request: The unmatched request\n        \"\"\"\n        super().__init__(\n            f\"No matching interaction for {request.protocol}:\"\n            f\"{request.action}:{request.target}\"\n        )\n        self.request: InteractionRequest = request\n</code></pre>"},{"location":"api/api_reference/#interposition.InteractionNotFoundError.__init__","title":"__init__","text":"<pre><code>__init__(request: InteractionRequest) -&gt; None\n</code></pre> <p>Initialize with request that failed to match.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>InteractionRequest</code> <p>The unmatched request</p> required Source code in <code>src/interposition/errors.py</code> <pre><code>def __init__(self, request: InteractionRequest) -&gt; None:\n    \"\"\"Initialize with request that failed to match.\n\n    Args:\n        request: The unmatched request\n    \"\"\"\n    super().__init__(\n        f\"No matching interaction for {request.protocol}:\"\n        f\"{request.action}:{request.target}\"\n    )\n    self.request: InteractionRequest = request\n</code></pre>"},{"location":"api/api_reference/#interposition.InteractionValidationError","title":"InteractionValidationError","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when interaction validation fails.</p> Source code in <code>src/interposition/models.py</code> <pre><code>class InteractionValidationError(ValueError):\n    \"\"\"Raised when interaction validation fails.\"\"\"\n</code></pre>"},{"location":"api/api_reference/#services","title":"Services","text":""},{"location":"api/api_reference/#interposition.services.Broker","title":"interposition.services.Broker","text":"<p>Manages interaction replay from cassettes.</p> <p>Attributes:</p> Name Type Description <code>cassette</code> <code>Cassette</code> <p>The cassette containing recorded interactions</p> Source code in <code>src/interposition/services.py</code> <pre><code>class Broker:\n    \"\"\"Manages interaction replay from cassettes.\n\n    Attributes:\n        cassette: The cassette containing recorded interactions\n    \"\"\"\n\n    def __init__(self, cassette: Cassette) -&gt; None:\n        \"\"\"Initialize broker with a cassette.\n\n        Args:\n            cassette: The cassette containing recorded interactions\n        \"\"\"\n        self._cassette = cassette\n\n    @property\n    def cassette(self) -&gt; Cassette:\n        \"\"\"Get the cassette.\"\"\"\n        return self._cassette\n\n    def replay(self, request: InteractionRequest) -&gt; Iterator[ResponseChunk]:\n        \"\"\"Replay recorded response for matching request.\n\n        Args:\n            request: The request to match and replay\n\n        Yields:\n            ResponseChunks in original recorded order\n\n        Raises:\n            InteractionNotFoundError: When no matching interaction exists\n        \"\"\"\n        fingerprint = request.fingerprint()\n        interaction = self.cassette.find_interaction(fingerprint)\n\n        if interaction is None:\n            raise InteractionNotFoundError(request)\n\n        yield from interaction.response_chunks\n</code></pre>"},{"location":"api/api_reference/#interposition.services.Broker.cassette","title":"cassette  <code>property</code>","text":"<pre><code>cassette: Cassette\n</code></pre> <p>Get the cassette.</p>"},{"location":"api/api_reference/#interposition.services.Broker.__init__","title":"__init__","text":"<pre><code>__init__(cassette: Cassette) -&gt; None\n</code></pre> <p>Initialize broker with a cassette.</p> <p>Parameters:</p> Name Type Description Default <code>cassette</code> <code>Cassette</code> <p>The cassette containing recorded interactions</p> required Source code in <code>src/interposition/services.py</code> <pre><code>def __init__(self, cassette: Cassette) -&gt; None:\n    \"\"\"Initialize broker with a cassette.\n\n    Args:\n        cassette: The cassette containing recorded interactions\n    \"\"\"\n    self._cassette = cassette\n</code></pre>"},{"location":"api/api_reference/#interposition.services.Broker.replay","title":"replay","text":"<pre><code>replay(\n    request: InteractionRequest,\n) -&gt; Iterator[ResponseChunk]\n</code></pre> <p>Replay recorded response for matching request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>InteractionRequest</code> <p>The request to match and replay</p> required <p>Yields:</p> Type Description <code>ResponseChunk</code> <p>ResponseChunks in original recorded order</p> <p>Raises:</p> Type Description <code>InteractionNotFoundError</code> <p>When no matching interaction exists</p> Source code in <code>src/interposition/services.py</code> <pre><code>def replay(self, request: InteractionRequest) -&gt; Iterator[ResponseChunk]:\n    \"\"\"Replay recorded response for matching request.\n\n    Args:\n        request: The request to match and replay\n\n    Yields:\n        ResponseChunks in original recorded order\n\n    Raises:\n        InteractionNotFoundError: When no matching interaction exists\n    \"\"\"\n    fingerprint = request.fingerprint()\n    interaction = self.cassette.find_interaction(fingerprint)\n\n    if interaction is None:\n        raise InteractionNotFoundError(request)\n\n    yield from interaction.response_chunks\n</code></pre>"},{"location":"api/api_reference/#models","title":"Models","text":""},{"location":"api/api_reference/#cassette","title":"Cassette","text":"<p>               Bases: <code>BaseModel</code></p> <p>In-memory collection of recorded interactions.</p> <p>Attributes:</p> Name Type Description <code>interactions</code> <code>tuple[Interaction, ...]</code> <p>Ordered sequence of interactions</p> Source code in <code>src/interposition/models.py</code> <pre><code>class Cassette(BaseModel):\n    \"\"\"In-memory collection of recorded interactions.\n\n    Attributes:\n        interactions: Ordered sequence of interactions\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    interactions: tuple[Interaction, ...]\n    _index: dict[RequestFingerprint, int] = PrivateAttr(default_factory=dict)\n\n    @model_validator(mode=\"after\")\n    def build_index(self) -&gt; Self:\n        \"\"\"Build fingerprint index for efficient lookup.\"\"\"\n        index: dict[RequestFingerprint, int] = {}\n        for i, interaction in enumerate(self.interactions):\n            # Only store first occurrence of each fingerprint\n            if interaction.fingerprint not in index:\n                index[interaction.fingerprint] = i\n        # Use object.__setattr__ to modify frozen model\n        object.__setattr__(self, \"_index\", index)\n        return self\n\n    def find_interaction(self, fingerprint: RequestFingerprint) -&gt; Interaction | None:\n        \"\"\"Find first interaction matching fingerprint.\n\n        Args:\n            fingerprint: Request fingerprint to search for\n\n        Returns:\n            Matching Interaction or None if not found\n        \"\"\"\n        position = self._index.get(fingerprint)\n        if position is None:\n            return None\n        return self.interactions[position]\n</code></pre>"},{"location":"api/api_reference/#interposition.models.Cassette.build_index","title":"build_index","text":"<pre><code>build_index() -&gt; Self\n</code></pre> <p>Build fingerprint index for efficient lookup.</p> Source code in <code>src/interposition/models.py</code> <pre><code>@model_validator(mode=\"after\")\ndef build_index(self) -&gt; Self:\n    \"\"\"Build fingerprint index for efficient lookup.\"\"\"\n    index: dict[RequestFingerprint, int] = {}\n    for i, interaction in enumerate(self.interactions):\n        # Only store first occurrence of each fingerprint\n        if interaction.fingerprint not in index:\n            index[interaction.fingerprint] = i\n    # Use object.__setattr__ to modify frozen model\n    object.__setattr__(self, \"_index\", index)\n    return self\n</code></pre>"},{"location":"api/api_reference/#interposition.models.Cassette.find_interaction","title":"find_interaction","text":"<pre><code>find_interaction(\n    fingerprint: RequestFingerprint,\n) -&gt; Interaction | None\n</code></pre> <p>Find first interaction matching fingerprint.</p> <p>Parameters:</p> Name Type Description Default <code>fingerprint</code> <code>RequestFingerprint</code> <p>Request fingerprint to search for</p> required <p>Returns:</p> Type Description <code>Interaction | None</code> <p>Matching Interaction or None if not found</p> Source code in <code>src/interposition/models.py</code> <pre><code>def find_interaction(self, fingerprint: RequestFingerprint) -&gt; Interaction | None:\n    \"\"\"Find first interaction matching fingerprint.\n\n    Args:\n        fingerprint: Request fingerprint to search for\n\n    Returns:\n        Matching Interaction or None if not found\n    \"\"\"\n    position = self._index.get(fingerprint)\n    if position is None:\n        return None\n    return self.interactions[position]\n</code></pre>"},{"location":"api/api_reference/#interaction","title":"Interaction","text":"<p>               Bases: <code>BaseModel</code></p> <p>Complete request-response pair for replay.</p> <p>Attributes:</p> Name Type Description <code>request</code> <code>InteractionRequest</code> <p>The original InteractionRequest</p> <code>fingerprint</code> <code>RequestFingerprint</code> <p>Precomputed request fingerprint for matching</p> <code>response_chunks</code> <code>tuple[ResponseChunk, ...]</code> <p>Ordered sequence of response chunks</p> <code>metadata</code> <code>tuple[tuple[str, str], ...]</code> <p>Optional interaction metadata as (key, value) pairs. Examples: recording timestamp, session ID, test scenario name. Useful for debugging and tracing recorded interactions. Default is empty tuple.</p> Source code in <code>src/interposition/models.py</code> <pre><code>class Interaction(BaseModel):\n    \"\"\"Complete request-response pair for replay.\n\n    Attributes:\n        request: The original InteractionRequest\n        fingerprint: Precomputed request fingerprint for matching\n        response_chunks: Ordered sequence of response chunks\n        metadata: Optional interaction metadata as (key, value) pairs.\n            Examples: recording timestamp, session ID, test scenario name.\n            Useful for debugging and tracing recorded interactions.\n            Default is empty tuple.\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    request: InteractionRequest\n    fingerprint: RequestFingerprint\n    response_chunks: tuple[ResponseChunk, ...]\n    metadata: tuple[tuple[str, str], ...] = ()\n\n    @model_validator(mode=\"after\")\n    def validate_interaction(self) -&gt; Self:\n        \"\"\"Validate interaction integrity.\n\n        Raises:\n            InteractionValidationError: If fingerprint doesn't match request\n                or chunks aren't sequential\n        \"\"\"\n        # Verify fingerprint matches request\n        expected_fingerprint = self.request.fingerprint()\n        if self.fingerprint != expected_fingerprint:\n            msg = (\n                f\"Fingerprint does not match request: \"\n                f\"expected {expected_fingerprint.value}, got {self.fingerprint.value}\"\n            )\n            raise InteractionValidationError(msg)\n\n        # Verify response chunks are sequentially ordered\n        if not self.response_chunks:\n            msg = \"Response chunks cannot be empty\"\n            raise InteractionValidationError(msg)\n\n        if self.response_chunks[0].sequence != 0:\n            msg = \"Response chunks must start at sequence 0\"\n            raise InteractionValidationError(msg)\n\n        for i, chunk in enumerate(self.response_chunks):\n            if chunk.sequence != i:\n                msg = \"Response chunks must be sequential with no gaps\"\n                raise InteractionValidationError(msg)\n\n        return self\n</code></pre>"},{"location":"api/api_reference/#interposition.models.Interaction.validate_interaction","title":"validate_interaction","text":"<pre><code>validate_interaction() -&gt; Self\n</code></pre> <p>Validate interaction integrity.</p> <p>Raises:</p> Type Description <code>InteractionValidationError</code> <p>If fingerprint doesn't match request or chunks aren't sequential</p> Source code in <code>src/interposition/models.py</code> <pre><code>@model_validator(mode=\"after\")\ndef validate_interaction(self) -&gt; Self:\n    \"\"\"Validate interaction integrity.\n\n    Raises:\n        InteractionValidationError: If fingerprint doesn't match request\n            or chunks aren't sequential\n    \"\"\"\n    # Verify fingerprint matches request\n    expected_fingerprint = self.request.fingerprint()\n    if self.fingerprint != expected_fingerprint:\n        msg = (\n            f\"Fingerprint does not match request: \"\n            f\"expected {expected_fingerprint.value}, got {self.fingerprint.value}\"\n        )\n        raise InteractionValidationError(msg)\n\n    # Verify response chunks are sequentially ordered\n    if not self.response_chunks:\n        msg = \"Response chunks cannot be empty\"\n        raise InteractionValidationError(msg)\n\n    if self.response_chunks[0].sequence != 0:\n        msg = \"Response chunks must start at sequence 0\"\n        raise InteractionValidationError(msg)\n\n    for i, chunk in enumerate(self.response_chunks):\n        if chunk.sequence != i:\n            msg = \"Response chunks must be sequential with no gaps\"\n            raise InteractionValidationError(msg)\n\n    return self\n</code></pre>"},{"location":"api/api_reference/#interactionrequest","title":"InteractionRequest","text":"<p>               Bases: <code>BaseModel</code></p> <p>Structured representation of a protocol-agnostic request.</p> <p>Attributes:</p> Name Type Description <code>protocol</code> <code>str</code> <p>Protocol identifier (e.g., \"grpc\", \"graphql\", \"mqtt\")</p> <code>action</code> <code>str</code> <p>Action/method name (e.g., \"ListUsers\", \"query\", \"publish\")</p> <code>target</code> <code>str</code> <p>Target resource (e.g., \"users.UserService\", \"topic/sensors\")</p> <code>headers</code> <code>tuple[tuple[str, str], ...]</code> <p>Request headers as immutable sequence of key-value pairs</p> <code>body</code> <code>bytes</code> <p>Request body content as bytes</p> Source code in <code>src/interposition/models.py</code> <pre><code>class InteractionRequest(BaseModel):\n    \"\"\"Structured representation of a protocol-agnostic request.\n\n    Attributes:\n        protocol: Protocol identifier (e.g., \"grpc\", \"graphql\", \"mqtt\")\n        action: Action/method name (e.g., \"ListUsers\", \"query\", \"publish\")\n        target: Target resource (e.g., \"users.UserService\", \"topic/sensors\")\n        headers: Request headers as immutable sequence of key-value pairs\n        body: Request body content as bytes\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    protocol: str\n    action: str\n    target: str\n    headers: tuple[tuple[str, str], ...]\n    body: bytes\n\n    def fingerprint(self) -&gt; RequestFingerprint:\n        \"\"\"Generate stable fingerprint for efficient matching.\n\n        Returns:\n            RequestFingerprint derived from all request fields.\n        \"\"\"\n        return RequestFingerprint.from_request(self)\n</code></pre>"},{"location":"api/api_reference/#interposition.models.InteractionRequest.fingerprint","title":"fingerprint","text":"<pre><code>fingerprint() -&gt; RequestFingerprint\n</code></pre> <p>Generate stable fingerprint for efficient matching.</p> <p>Returns:</p> Type Description <code>RequestFingerprint</code> <p>RequestFingerprint derived from all request fields.</p> Source code in <code>src/interposition/models.py</code> <pre><code>def fingerprint(self) -&gt; RequestFingerprint:\n    \"\"\"Generate stable fingerprint for efficient matching.\n\n    Returns:\n        RequestFingerprint derived from all request fields.\n    \"\"\"\n    return RequestFingerprint.from_request(self)\n</code></pre>"},{"location":"api/api_reference/#responsechunk","title":"ResponseChunk","text":"<p>               Bases: <code>BaseModel</code></p> <p>Discrete piece of response data.</p> <p>Attributes:</p> Name Type Description <code>data</code> <code>bytes</code> <p>Chunk payload as bytes</p> <code>sequence</code> <code>int</code> <p>Zero-based chunk position in response stream</p> <code>metadata</code> <code>tuple[tuple[str, str], ...]</code> <p>Optional chunk metadata as (key, value) string pairs. Examples: timing info, encoding, content-type for this chunk. Default is empty tuple.</p> Source code in <code>src/interposition/models.py</code> <pre><code>class ResponseChunk(BaseModel):\n    \"\"\"Discrete piece of response data.\n\n    Attributes:\n        data: Chunk payload as bytes\n        sequence: Zero-based chunk position in response stream\n        metadata: Optional chunk metadata as (key, value) string pairs.\n            Examples: timing info, encoding, content-type for this chunk.\n            Default is empty tuple.\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    data: bytes\n    sequence: int\n    metadata: tuple[tuple[str, str], ...] = ()\n</code></pre>"},{"location":"api/api_reference/#requestfingerprint","title":"RequestFingerprint","text":"<p>               Bases: <code>BaseModel</code></p> <p>Stable unique identifier for request matching.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>str</code> <p>SHA-256 hash of canonicalized request fields</p> Source code in <code>src/interposition/models.py</code> <pre><code>class RequestFingerprint(BaseModel):\n    \"\"\"Stable unique identifier for request matching.\n\n    Attributes:\n        value: SHA-256 hash of canonicalized request fields\n    \"\"\"\n\n    model_config = ConfigDict(frozen=True)\n\n    value: str\n\n    @field_validator(\"value\")\n    @classmethod\n    def validate_sha256_hex(cls, v: str) -&gt; str:\n        \"\"\"Validate that value is a valid SHA-256 hex string.\n\n        Args:\n            v: The fingerprint value to validate\n\n        Returns:\n            The validated value\n\n        Raises:\n            ValueError: If value is not exactly 64 hex characters\n        \"\"\"\n        if len(v) != SHA256_HEX_LENGTH:\n            msg = f\"SHA-256 hex must be exactly {SHA256_HEX_LENGTH} characters\"\n            raise ValueError(msg)\n        if not all(c in \"0123456789abcdef\" for c in v):\n            msg = \"Invalid hex characters in fingerprint\"\n            raise ValueError(msg)\n        return v\n\n    @classmethod\n    def from_request(cls, request: InteractionRequest) -&gt; Self:\n        \"\"\"Create fingerprint from InteractionRequest.\n\n        Args:\n            request: The request to fingerprint\n\n        Returns:\n            RequestFingerprint with SHA-256 hash value\n        \"\"\"\n        # Canonical order: protocol, action, target, headers, body\n        # Preserve header ordering to avoid normalization.\n        canonical_data = [\n            request.protocol,\n            request.action,\n            request.target,\n            request.headers,\n            request.body.hex(),\n        ]\n        canonical = json.dumps(\n            canonical_data,\n            separators=_CANONICAL_JSON_SEPARATORS,\n            sort_keys=_CANONICAL_JSON_SORT_KEYS,\n        )\n        hash_value = hashlib.sha256(canonical.encode(\"utf-8\")).hexdigest()\n        return cls(value=hash_value)\n</code></pre>"},{"location":"api/api_reference/#interposition.models.RequestFingerprint.validate_sha256_hex","title":"validate_sha256_hex  <code>classmethod</code>","text":"<pre><code>validate_sha256_hex(v: str) -&gt; str\n</code></pre> <p>Validate that value is a valid SHA-256 hex string.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>str</code> <p>The fingerprint value to validate</p> required <p>Returns:</p> Type Description <code>str</code> <p>The validated value</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If value is not exactly 64 hex characters</p> Source code in <code>src/interposition/models.py</code> <pre><code>@field_validator(\"value\")\n@classmethod\ndef validate_sha256_hex(cls, v: str) -&gt; str:\n    \"\"\"Validate that value is a valid SHA-256 hex string.\n\n    Args:\n        v: The fingerprint value to validate\n\n    Returns:\n        The validated value\n\n    Raises:\n        ValueError: If value is not exactly 64 hex characters\n    \"\"\"\n    if len(v) != SHA256_HEX_LENGTH:\n        msg = f\"SHA-256 hex must be exactly {SHA256_HEX_LENGTH} characters\"\n        raise ValueError(msg)\n    if not all(c in \"0123456789abcdef\" for c in v):\n        msg = \"Invalid hex characters in fingerprint\"\n        raise ValueError(msg)\n    return v\n</code></pre>"},{"location":"api/api_reference/#interposition.models.RequestFingerprint.from_request","title":"from_request  <code>classmethod</code>","text":"<pre><code>from_request(request: InteractionRequest) -&gt; Self\n</code></pre> <p>Create fingerprint from InteractionRequest.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>InteractionRequest</code> <p>The request to fingerprint</p> required <p>Returns:</p> Type Description <code>Self</code> <p>RequestFingerprint with SHA-256 hash value</p> Source code in <code>src/interposition/models.py</code> <pre><code>@classmethod\ndef from_request(cls, request: InteractionRequest) -&gt; Self:\n    \"\"\"Create fingerprint from InteractionRequest.\n\n    Args:\n        request: The request to fingerprint\n\n    Returns:\n        RequestFingerprint with SHA-256 hash value\n    \"\"\"\n    # Canonical order: protocol, action, target, headers, body\n    # Preserve header ordering to avoid normalization.\n    canonical_data = [\n        request.protocol,\n        request.action,\n        request.target,\n        request.headers,\n        request.body.hex(),\n    ]\n    canonical = json.dumps(\n        canonical_data,\n        separators=_CANONICAL_JSON_SEPARATORS,\n        sort_keys=_CANONICAL_JSON_SORT_KEYS,\n    )\n    hash_value = hashlib.sha256(canonical.encode(\"utf-8\")).hexdigest()\n    return cls(value=hash_value)\n</code></pre>"},{"location":"api/api_reference/#exceptions","title":"Exceptions","text":""},{"location":"api/api_reference/#interactionnotfounderror","title":"InteractionNotFoundError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when no matching interaction is found in cassette.</p> Source code in <code>src/interposition/errors.py</code> <pre><code>class InteractionNotFoundError(Exception):\n    \"\"\"Raised when no matching interaction is found in cassette.\"\"\"\n\n    def __init__(self, request: InteractionRequest) -&gt; None:\n        \"\"\"Initialize with request that failed to match.\n\n        Args:\n            request: The unmatched request\n        \"\"\"\n        super().__init__(\n            f\"No matching interaction for {request.protocol}:\"\n            f\"{request.action}:{request.target}\"\n        )\n        self.request: InteractionRequest = request\n</code></pre>"},{"location":"api/api_reference/#interposition.errors.InteractionNotFoundError.__init__","title":"__init__","text":"<pre><code>__init__(request: InteractionRequest) -&gt; None\n</code></pre> <p>Initialize with request that failed to match.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>InteractionRequest</code> <p>The unmatched request</p> required Source code in <code>src/interposition/errors.py</code> <pre><code>def __init__(self, request: InteractionRequest) -&gt; None:\n    \"\"\"Initialize with request that failed to match.\n\n    Args:\n        request: The unmatched request\n    \"\"\"\n    super().__init__(\n        f\"No matching interaction for {request.protocol}:\"\n        f\"{request.action}:{request.target}\"\n    )\n    self.request: InteractionRequest = request\n</code></pre>"},{"location":"api/api_reference/#interactionvalidationerror","title":"InteractionValidationError","text":"<p>               Bases: <code>ValueError</code></p> <p>Raised when interaction validation fails.</p> Source code in <code>src/interposition/models.py</code> <pre><code>class InteractionValidationError(ValueError):\n    \"\"\"Raised when interaction validation fails.\"\"\"\n</code></pre>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>This document provides a high-level overview of architectural decisions made for the interposition project.</p>"},{"location":"architecture/overview/#architecture-decision-records","title":"Architecture Decision Records","text":""},{"location":"architecture/overview/#adr-0001-use-pydantic-v2-for-data-models","title":"ADR-0001: Use Pydantic v2 for Data Models","text":"<p>Status: Accepted | Date: 2026-01-05</p> <p>Use Pydantic v2 BaseModel for all data models to enable serialization, runtime validation, and immutability without custom code.</p>"},{"location":"architecture/overview/#adr-0002-use-sha-256-for-request-fingerprinting","title":"ADR-0002: Use SHA-256 for Request Fingerprinting","text":"<p>Status: Accepted | Date: 2026-01-05</p> <p>Use SHA-256 hash of canonicalized request fields as fingerprints for efficient and collision-resistant interaction matching.</p>"},{"location":"architecture/overview/#adr-0003-use-generator-pattern-for-response-streaming","title":"ADR-0003: Use Generator Pattern for Response Streaming","text":"<p>Status: Accepted | Date: 2026-01-05</p> <p>Use Python generators for streaming response chunks to enable lazy evaluation, memory efficiency, and backpressure support.</p>"},{"location":"architecture/overview/#adr-0004-use-first-match-strategy-for-duplicate-interactions","title":"ADR-0004: Use First-Match Strategy for Duplicate Interactions","text":"<p>Status: Accepted | Date: 2026-01-05</p> <p>When multiple interactions have identical fingerprints, return the first match to ensure deterministic and predictable replay behavior.</p>"},{"location":"architecture/overview/#adr-0005-build-fingerprint-index-for-o1-lookup","title":"ADR-0005: Build Fingerprint Index for O(1) Lookup","text":"<p>Status: Accepted | Date: 2026-01-05</p> <p>Build an in-memory hash map index from fingerprints to interaction positions at cassette construction time for O(1) lookup performance.</p>"},{"location":"guides/adapters/","title":"Protocol Adapters Guide","text":"<p>Interposition is a pure logic engine. It knows how to store and match interactions, but it doesn't know how to talk to the network or your database.</p> <p>To bridge this gap, you use Adapters.</p>"},{"location":"guides/adapters/#what-is-an-adapter","title":"What is an Adapter?","text":"<p>An Adapter is a piece of code that sits between your application (or its libraries) and Interposition.</p> <p>Its responsibilities are: 1.  Intercept: Catch the outgoing request (HTTP, SQL, etc.). 2.  Translate: Convert that request into an <code>InteractionRequest</code>. 3.  Delegate: Ask the Interposition <code>Broker</code> for a response. 4.  Return: Convert the <code>ResponseChunk</code>s back into the native response format (e.g., <code>requests.Response</code> or SQL rows).</p>"},{"location":"guides/adapters/#implementation-strategies","title":"Implementation Strategies","text":"<p>There are two main ways to implement an adapter, depending on your testing needs.</p>"},{"location":"guides/adapters/#1-monkey-patching-internal","title":"1. Monkey Patching (Internal)","text":"<p>Best for: Unit Tests, Python-only projects, No Dependencies.</p> <p>In this strategy, you replace a library's internal method (like <code>urllib.request.OpenerDirector.open</code> or <code>sqlalchemy.engine.Connection.execute</code>) with your own function or handler.</p> <p>Pros: *   Fast and lightweight. *   No need to change application configuration (URLs). *   Zero external dependencies (if using standard library).</p> <p>Cons: *   Only works for Python code running in the same process. *   Relies on library internals.</p> <p>\ud83d\udc49 See Example: urllib Adapter</p>"},{"location":"guides/adapters/#2-proxy-server-external","title":"2. Proxy Server (External)","text":"<p>Best for: E2E Tests, External Processes, Non-Python Clients.</p> <p>In this strategy, you run a small server (a proxy) that Interposition controls. You configure your application to send traffic to this proxy.</p> <p>Pros: *   Language Agnostic: Works with <code>curl</code>, Node.js, Go, etc. *   Process Agnostic: Works even if your app runs in a separate Docker container. *   Clean: Does not mess with library internals.</p> <p>Cons: *   Requires changing application config (e.g., setting <code>HTTP_PROXY</code>). *   Slightly more complex setup.</p> <p>\ud83d\udc49 See Example: HTTP Proxy Server</p>"},{"location":"guides/adapters/#why-arent-adapters-included","title":"Why aren't adapters included?","text":"<p>We decided not to include built-in adapters (like <code>interposition.adapters.requests</code>) in the core package.  See ADR 0006: External Protocol Adapters for the detailed reasoning.</p> <p>In short: We want to keep the core lightweight and protocol-agnostic. By copying the examples and modifying them, you get full control over exactly how the interception happens.</p>"}]}